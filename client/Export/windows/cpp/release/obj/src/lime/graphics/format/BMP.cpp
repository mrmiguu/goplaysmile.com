// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_format_BMP
#include <lime/graphics/format/BMP.h>
#endif
#ifndef INCLUDED_lime_graphics_format_BMPType
#include <lime/graphics/format/BMPType.h>
#endif
#ifndef INCLUDED_lime_math_Rectangle
#include <lime/math/Rectangle.h>
#endif

namespace lime{
namespace graphics{
namespace format{

void BMP_obj::__construct() { }

Dynamic BMP_obj::__CreateEmpty() { return new BMP_obj; }

hx::ObjectPtr< BMP_obj > BMP_obj::__new()
{
	hx::ObjectPtr< BMP_obj > _hx_result = new BMP_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic BMP_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< BMP_obj > _hx_result = new BMP_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::haxe::io::Bytes BMP_obj::encode( ::lime::graphics::Image image,::hx::EnumBase type){
            	HX_STACK_FRAME("lime.graphics.format.BMP","encode",0xdcae556c,"lime.graphics.format.BMP.encode","lime/graphics/format/BMP.hx",12,0xe68a6e47)
            	HX_STACK_ARG(image,"image")
            	HX_STACK_ARG(type,"type")
HXLINE(  14)		Bool _hx_tmp;
HXDLIN(  14)		Bool _hx_tmp1 = !(image->get_premultiplied());
HXDLIN(  14)		if (_hx_tmp1) {
HXLINE(  14)			Int _hx_tmp2 = image->get_format();
HXDLIN(  14)			_hx_tmp = (_hx_tmp2 != (int)0);
            		}
            		else {
HXLINE(  14)			_hx_tmp = true;
            		}
HXDLIN(  14)		if (_hx_tmp) {
HXLINE(  18)			image = image->clone();
HXLINE(  19)			image->set_premultiplied(false);
HXLINE(  20)			image->set_format((int)0);
            		}
HXLINE(  24)		Bool _hx_tmp3 = hx::IsNull( type );
HXDLIN(  24)		if (_hx_tmp3) {
HXLINE(  26)			type = ::lime::graphics::format::BMPType_obj::RGB_dyn();
            		}
HXLINE(  30)		HX_VARI( Int,fileHeaderLength) = (int)14;
HXLINE(  31)		HX_VARI( Int,infoHeaderLength) = (int)40;
HXLINE(  32)		HX_VARI( Int,pixelValuesLength) = ((image->width * image->height) * (int)4);
HXLINE(  34)		Bool _hx_tmp4 = hx::IsNull( type );
HXDLIN(  34)		if (!(_hx_tmp4)) {
HXLINE(  34)			Int _hx_tmp5 = ( ( ::hx::EnumBase)(type) )->_hx_getIndex();
HXDLIN(  34)			switch((int)(_hx_tmp5)){
            				case (int)0: {
HXLINE(  47)					pixelValuesLength = ((((image->width * (int)3) + hx::Mod((image->width * (int)3),(int)4)) + (image->height * (int)3)) + (image->height * (int)3));
            				}
            				break;
            				case (int)1: {
HXLINE(  38)					infoHeaderLength = (int)108;
            				}
            				break;
            				case (int)2: {
HXLINE(  42)					fileHeaderLength = (int)0;
HXLINE(  43)					hx::AddEq(pixelValuesLength,(image->width * image->height));
            				}
            				break;
            			}
            		}
HXLINE(  53)		HX_VARI(  ::haxe::io::Bytes,data) = ::haxe::io::Bytes_obj::alloc(((fileHeaderLength + infoHeaderLength) + pixelValuesLength));
HXLINE(  54)		HX_VARI( Int,position) = (int)0;
HXLINE(  56)		if ((fileHeaderLength > (int)0)) {
HXLINE(  58)			{
HXLINE(  58)				position = (int)1;
HXDLIN(  58)				data->b[(int)0] = (int)66;
            			}
HXLINE(  59)			{
HXLINE(  59)				position = (int)2;
HXDLIN(  59)				data->b[(int)1] = (int)77;
            			}
HXLINE(  60)			{
HXLINE(  60)				HX_VARI( Int,v) = data->length;
HXDLIN(  60)				data->b[(int)2] = v;
HXDLIN(  60)				data->b[(int)3] = ((int)v >> (int)(int)8);
HXDLIN(  60)				data->b[(int)4] = ((int)v >> (int)(int)16);
HXDLIN(  60)				data->b[(int)5] = hx::UShr(v,(int)24);
            			}
HXDLIN(  60)			position = (int)6;
HXLINE(  61)			{
HXLINE(  61)				data->b[(int)6] = (int)0;
HXDLIN(  61)				data->b[(int)7] = (int)0;
            			}
HXDLIN(  61)			position = (int)8;
HXLINE(  62)			{
HXLINE(  62)				data->b[(int)8] = (int)0;
HXDLIN(  62)				data->b[(int)9] = (int)0;
            			}
HXDLIN(  62)			position = (int)10;
HXLINE(  63)			{
HXLINE(  63)				HX_VARI_NAME( Int,v1,"v") = (fileHeaderLength + infoHeaderLength);
HXDLIN(  63)				data->b[(int)10] = v1;
HXDLIN(  63)				data->b[(int)11] = ((int)v1 >> (int)(int)8);
HXDLIN(  63)				data->b[(int)12] = ((int)v1 >> (int)(int)16);
HXDLIN(  63)				data->b[(int)13] = hx::UShr(v1,(int)24);
            			}
HXDLIN(  63)			position = (int)14;
            		}
HXLINE(  67)		{
HXLINE(  67)			data->b[position] = infoHeaderLength;
HXDLIN(  67)			data->b[(position + (int)1)] = ((int)infoHeaderLength >> (int)(int)8);
HXDLIN(  67)			data->b[(position + (int)2)] = ((int)infoHeaderLength >> (int)(int)16);
HXDLIN(  67)			data->b[(position + (int)3)] = hx::UShr(infoHeaderLength,(int)24);
            		}
HXDLIN(  67)		hx::AddEq(position,(int)4);
HXLINE(  68)		{
HXLINE(  68)			HX_VARI_NAME( Int,v2,"v") = image->width;
HXDLIN(  68)			data->b[position] = v2;
HXDLIN(  68)			data->b[(position + (int)1)] = ((int)v2 >> (int)(int)8);
HXDLIN(  68)			data->b[(position + (int)2)] = ((int)v2 >> (int)(int)16);
HXDLIN(  68)			data->b[(position + (int)3)] = hx::UShr(v2,(int)24);
            		}
HXDLIN(  68)		hx::AddEq(position,(int)4);
HXLINE(  69)		{
HXLINE(  69)			HX_VAR_NAME( Int,v3,"v");
HXDLIN(  69)			if (hx::IsEq( type,::lime::graphics::format::BMPType_obj::ICO_dyn() )) {
HXLINE(  69)				v3 = (image->height * (int)2);
            			}
            			else {
HXLINE(  69)				v3 = image->height;
            			}
HXDLIN(  69)			data->b[position] = v3;
HXDLIN(  69)			data->b[(position + (int)1)] = ((int)v3 >> (int)(int)8);
HXDLIN(  69)			data->b[(position + (int)2)] = ((int)v3 >> (int)(int)16);
HXDLIN(  69)			data->b[(position + (int)3)] = hx::UShr(v3,(int)24);
            		}
HXDLIN(  69)		hx::AddEq(position,(int)4);
HXLINE(  70)		{
HXLINE(  70)			data->b[position] = (int)1;
HXDLIN(  70)			data->b[(position + (int)1)] = (int)0;
            		}
HXDLIN(  70)		hx::AddEq(position,(int)2);
HXLINE(  71)		{
HXLINE(  71)			HX_VAR_NAME( Int,v4,"v");
HXDLIN(  71)			if (hx::IsEq( type,::lime::graphics::format::BMPType_obj::RGB_dyn() )) {
HXLINE(  71)				v4 = (int)24;
            			}
            			else {
HXLINE(  71)				v4 = (int)32;
            			}
HXDLIN(  71)			data->b[position] = v4;
HXDLIN(  71)			data->b[(position + (int)1)] = ((int)v4 >> (int)(int)8);
            		}
HXDLIN(  71)		hx::AddEq(position,(int)2);
HXLINE(  72)		{
HXLINE(  72)			HX_VAR_NAME( Int,v5,"v");
HXDLIN(  72)			if (hx::IsEq( type,::lime::graphics::format::BMPType_obj::BITFIELD_dyn() )) {
HXLINE(  72)				v5 = (int)3;
            			}
            			else {
HXLINE(  72)				v5 = (int)0;
            			}
HXDLIN(  72)			data->b[position] = v5;
HXDLIN(  72)			data->b[(position + (int)1)] = ((int)v5 >> (int)(int)8);
HXDLIN(  72)			data->b[(position + (int)2)] = ((int)v5 >> (int)(int)16);
HXDLIN(  72)			data->b[(position + (int)3)] = hx::UShr(v5,(int)24);
            		}
HXDLIN(  72)		hx::AddEq(position,(int)4);
HXLINE(  73)		{
HXLINE(  73)			data->b[position] = pixelValuesLength;
HXDLIN(  73)			data->b[(position + (int)1)] = ((int)pixelValuesLength >> (int)(int)8);
HXDLIN(  73)			data->b[(position + (int)2)] = ((int)pixelValuesLength >> (int)(int)16);
HXDLIN(  73)			data->b[(position + (int)3)] = hx::UShr(pixelValuesLength,(int)24);
            		}
HXDLIN(  73)		hx::AddEq(position,(int)4);
HXLINE(  74)		{
HXLINE(  74)			data->b[position] = (int)11824;
HXDLIN(  74)			data->b[(position + (int)1)] = (int)46;
HXDLIN(  74)			data->b[(position + (int)2)] = (int)0;
HXDLIN(  74)			data->b[(position + (int)3)] = (int)0;
            		}
HXDLIN(  74)		hx::AddEq(position,(int)4);
HXLINE(  75)		{
HXLINE(  75)			data->b[position] = (int)11824;
HXDLIN(  75)			data->b[(position + (int)1)] = (int)46;
HXDLIN(  75)			data->b[(position + (int)2)] = (int)0;
HXDLIN(  75)			data->b[(position + (int)3)] = (int)0;
            		}
HXDLIN(  75)		hx::AddEq(position,(int)4);
HXLINE(  76)		{
HXLINE(  76)			data->b[position] = (int)0;
HXDLIN(  76)			data->b[(position + (int)1)] = (int)0;
HXDLIN(  76)			data->b[(position + (int)2)] = (int)0;
HXDLIN(  76)			data->b[(position + (int)3)] = (int)0;
            		}
HXDLIN(  76)		hx::AddEq(position,(int)4);
HXLINE(  77)		{
HXLINE(  77)			data->b[position] = (int)0;
HXDLIN(  77)			data->b[(position + (int)1)] = (int)0;
HXDLIN(  77)			data->b[(position + (int)2)] = (int)0;
HXDLIN(  77)			data->b[(position + (int)3)] = (int)0;
            		}
HXDLIN(  77)		hx::AddEq(position,(int)4);
HXLINE(  79)		if (hx::IsEq( type,::lime::graphics::format::BMPType_obj::BITFIELD_dyn() )) {
HXLINE(  81)			{
HXLINE(  81)				data->b[position] = (int)16711680;
HXDLIN(  81)				data->b[(position + (int)1)] = (int)65280;
HXDLIN(  81)				data->b[(position + (int)2)] = (int)255;
HXDLIN(  81)				data->b[(position + (int)3)] = (int)0;
            			}
HXDLIN(  81)			hx::AddEq(position,(int)4);
HXLINE(  82)			{
HXLINE(  82)				data->b[position] = (int)65280;
HXDLIN(  82)				data->b[(position + (int)1)] = (int)255;
HXDLIN(  82)				data->b[(position + (int)2)] = (int)0;
HXDLIN(  82)				data->b[(position + (int)3)] = (int)0;
            			}
HXDLIN(  82)			hx::AddEq(position,(int)4);
HXLINE(  83)			{
HXLINE(  83)				data->b[position] = (int)255;
HXDLIN(  83)				data->b[(position + (int)1)] = (int)0;
HXDLIN(  83)				data->b[(position + (int)2)] = (int)0;
HXDLIN(  83)				data->b[(position + (int)3)] = (int)0;
            			}
HXDLIN(  83)			hx::AddEq(position,(int)4);
HXLINE(  84)			{
HXLINE(  84)				data->b[position] = (int)-16777216;
HXDLIN(  84)				data->b[(position + (int)1)] = (int)-65536;
HXDLIN(  84)				data->b[(position + (int)2)] = (int)-256;
HXDLIN(  84)				data->b[(position + (int)3)] = (int)255;
            			}
HXDLIN(  84)			hx::AddEq(position,(int)4);
HXLINE(  86)			{
HXLINE(  86)				Int pos = position++;
HXDLIN(  86)				data->b[pos] = (int)32;
            			}
HXLINE(  87)			{
HXLINE(  87)				Int pos1 = position++;
HXDLIN(  87)				data->b[pos1] = (int)110;
            			}
HXLINE(  88)			{
HXLINE(  88)				Int pos2 = position++;
HXDLIN(  88)				data->b[pos2] = (int)105;
            			}
HXLINE(  89)			{
HXLINE(  89)				Int pos3 = position++;
HXDLIN(  89)				data->b[pos3] = (int)87;
            			}
HXLINE(  91)			{
HXLINE(  91)				HX_VARI( Int,_g) = (int)0;
HXDLIN(  91)				while((_g < (int)48)){
HXLINE(  91)					++_g;
HXLINE(  93)					{
HXLINE(  93)						Int pos4 = position++;
HXDLIN(  93)						data->b[pos4] = (int)0;
            					}
            				}
            			}
            		}
HXLINE(  99)		HX_VARI(  ::haxe::io::Bytes,pixels) = image->getPixels( ::lime::math::Rectangle_obj::__new((int)0,(int)0,image->width,image->height),(int)1);
HXLINE( 100)		HX_VARI( Int,readPosition) = (int)0;
HXLINE( 101)		HX_VAR( Int,a);
HXDLIN( 101)		HX_VAR( Int,r);
HXDLIN( 101)		HX_VAR( Int,g);
HXDLIN( 101)		HX_VAR( Int,b);
HXLINE( 103)		Bool _hx_tmp6 = hx::IsNull( type );
HXDLIN( 103)		if (!(_hx_tmp6)) {
HXLINE( 103)			Int _hx_tmp7 = ( ( ::hx::EnumBase)(type) )->_hx_getIndex();
HXDLIN( 103)			switch((int)(_hx_tmp7)){
            				case (int)0: {
HXLINE( 166)					HX_VARI( Int,_g1) = (int)0;
HXDLIN( 166)					HX_VARI_NAME( Int,_g2,"_g") = image->height;
HXDLIN( 166)					while((_g1 < _g2)){
HXLINE( 166)						HX_VARI( Int,y) = _g1++;
HXLINE( 168)						readPosition = ((((image->height - (int)1) - y) * (int)4) * image->width);
HXLINE( 170)						{
HXLINE( 170)							HX_VARI( Int,_g3) = (int)0;
HXDLIN( 170)							HX_VARI_NAME( Int,_g21,"_g2") = image->width;
HXDLIN( 170)							while((_g3 < _g21)){
HXLINE( 170)								++_g3;
HXLINE( 172)								++readPosition;
HXLINE( 173)								Int pos5 = readPosition++;
HXDLIN( 173)								r = pixels->b->__get(pos5);
HXLINE( 174)								Int pos6 = readPosition++;
HXDLIN( 174)								g = pixels->b->__get(pos6);
HXLINE( 175)								Int pos7 = readPosition++;
HXDLIN( 175)								b = pixels->b->__get(pos7);
HXLINE( 177)								{
HXLINE( 177)									Int pos8 = position++;
HXDLIN( 177)									data->b[pos8] = b;
            								}
HXLINE( 178)								{
HXLINE( 178)									Int pos9 = position++;
HXDLIN( 178)									data->b[pos9] = g;
            								}
HXLINE( 179)								{
HXLINE( 179)									Int pos10 = position++;
HXDLIN( 179)									data->b[pos10] = r;
            								}
            							}
            						}
HXLINE( 183)						{
HXLINE( 183)							HX_VARI_NAME( Int,_g31,"_g3") = (int)0;
HXDLIN( 183)							HX_VARI_NAME( Int,_g22,"_g2") = hx::Mod((image->width * (int)3),(int)4);
HXDLIN( 183)							while((_g31 < _g22)){
HXLINE( 183)								++_g31;
HXLINE( 185)								{
HXLINE( 185)									Int pos11 = position++;
HXDLIN( 185)									data->b[pos11] = (int)0;
            								}
            							}
            						}
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 107)					HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 107)					HX_VARI_NAME( Int,_g4,"_g") = image->height;
HXDLIN( 107)					while((_g11 < _g4)){
HXLINE( 107)						HX_VARI_NAME( Int,y1,"y") = _g11++;
HXLINE( 109)						readPosition = ((((image->height - (int)1) - y1) * (int)4) * image->width);
HXLINE( 111)						{
HXLINE( 111)							HX_VARI_NAME( Int,_g32,"_g3") = (int)0;
HXDLIN( 111)							HX_VARI_NAME( Int,_g23,"_g2") = image->width;
HXDLIN( 111)							while((_g32 < _g23)){
HXLINE( 111)								++_g32;
HXLINE( 113)								Int pos12 = readPosition++;
HXDLIN( 113)								a = pixels->b->__get(pos12);
HXLINE( 114)								Int pos13 = readPosition++;
HXDLIN( 114)								r = pixels->b->__get(pos13);
HXLINE( 115)								Int pos14 = readPosition++;
HXDLIN( 115)								g = pixels->b->__get(pos14);
HXLINE( 116)								Int pos15 = readPosition++;
HXDLIN( 116)								b = pixels->b->__get(pos15);
HXLINE( 118)								{
HXLINE( 118)									Int pos16 = position++;
HXDLIN( 118)									data->b[pos16] = b;
            								}
HXLINE( 119)								{
HXLINE( 119)									Int pos17 = position++;
HXDLIN( 119)									data->b[pos17] = g;
            								}
HXLINE( 120)								{
HXLINE( 120)									Int pos18 = position++;
HXDLIN( 120)									data->b[pos18] = r;
            								}
HXLINE( 121)								{
HXLINE( 121)									Int pos19 = position++;
HXDLIN( 121)									data->b[pos19] = a;
            								}
            							}
            						}
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 129)					Int _hx_tmp8 = (image->width * image->height);
HXDLIN( 129)					HX_VARI(  ::haxe::io::Bytes,andMask) = ::haxe::io::Bytes_obj::alloc(_hx_tmp8);
HXLINE( 130)					HX_VARI( Int,maskPosition) = (int)0;
HXLINE( 132)					{
HXLINE( 132)						HX_VARI_NAME( Int,_g12,"_g1") = (int)0;
HXDLIN( 132)						HX_VARI_NAME( Int,_g5,"_g") = image->height;
HXDLIN( 132)						while((_g12 < _g5)){
HXLINE( 132)							HX_VARI_NAME( Int,y2,"y") = _g12++;
HXLINE( 134)							readPosition = ((((image->height - (int)1) - y2) * (int)4) * image->width);
HXLINE( 136)							{
HXLINE( 136)								HX_VARI_NAME( Int,_g33,"_g3") = (int)0;
HXDLIN( 136)								HX_VARI_NAME( Int,_g24,"_g2") = image->width;
HXDLIN( 136)								while((_g33 < _g24)){
HXLINE( 136)									++_g33;
HXLINE( 138)									Int pos20 = readPosition++;
HXDLIN( 138)									a = pixels->b->__get(pos20);
HXLINE( 139)									Int pos21 = readPosition++;
HXDLIN( 139)									r = pixels->b->__get(pos21);
HXLINE( 140)									Int pos22 = readPosition++;
HXDLIN( 140)									g = pixels->b->__get(pos22);
HXLINE( 141)									Int pos23 = readPosition++;
HXDLIN( 141)									b = pixels->b->__get(pos23);
HXLINE( 143)									{
HXLINE( 143)										Int pos24 = position++;
HXDLIN( 143)										data->b[pos24] = b;
            									}
HXLINE( 144)									{
HXLINE( 144)										Int pos25 = position++;
HXDLIN( 144)										data->b[pos25] = g;
            									}
HXLINE( 145)									{
HXLINE( 145)										Int pos26 = position++;
HXDLIN( 145)										data->b[pos26] = r;
            									}
HXLINE( 146)									{
HXLINE( 146)										Int pos27 = position++;
HXDLIN( 146)										data->b[pos27] = a;
            									}
HXLINE( 154)									{
HXLINE( 154)										Int pos28 = maskPosition++;
HXDLIN( 154)										andMask->b[pos28] = (int)0;
            									}
            								}
            							}
            						}
            					}
HXLINE( 162)					Int _hx_tmp9 = (image->width * image->height);
HXDLIN( 162)					data->blit(position,andMask,(int)0,_hx_tmp9);
            				}
            				break;
            			}
            		}
HXLINE( 195)		return data;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(BMP_obj,encode,return )


BMP_obj::BMP_obj()
{
}

bool BMP_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"encode") ) { outValue = encode_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *BMP_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *BMP_obj_sStaticStorageInfo = 0;
#endif

static void BMP_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(BMP_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void BMP_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(BMP_obj::__mClass,"__mClass");
};

#endif

hx::Class BMP_obj::__mClass;

static ::String BMP_obj_sStaticFields[] = {
	HX_HCSTRING("encode","\x16","\xf2","\xe3","\xf9"),
	::String(null())
};

void BMP_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("lime.graphics.format.BMP","\x58","\xee","\xa1","\x4b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &BMP_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = BMP_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(BMP_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< BMP_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = BMP_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BMP_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BMP_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace graphics
} // end namespace format

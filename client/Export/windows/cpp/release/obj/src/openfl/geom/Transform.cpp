// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix3D
#include <openfl/geom/Matrix3D.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_geom_Transform
#include <openfl/geom/Transform.h>
#endif

namespace openfl{
namespace geom{

void Transform_obj::__construct( ::openfl::display::DisplayObject displayObject){
            	HX_STACK_FRAME("openfl.geom.Transform","new",0x993cc92a,"openfl.geom.Transform.new","openfl/geom/Transform.hx",26,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(displayObject,"displayObject")
HXLINE(  28)		this->_hx___colorTransform =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  29)		this->concatenatedColorTransform =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  30)		this->pixelBounds =  ::openfl::geom::Rectangle_obj::__new(null(),null(),null(),null());
HXLINE(  32)		this->_hx___displayObject = displayObject;
HXLINE(  33)		this->_hx___hasMatrix = true;
            	}

Dynamic Transform_obj::__CreateEmpty() { return new Transform_obj; }

hx::ObjectPtr< Transform_obj > Transform_obj::__new( ::openfl::display::DisplayObject displayObject)
{
	hx::ObjectPtr< Transform_obj > _hx_result = new Transform_obj();
	_hx_result->__construct(displayObject);
	return _hx_result;
}

Dynamic Transform_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Transform_obj > _hx_result = new Transform_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

 ::openfl::geom::ColorTransform Transform_obj::get_colorTransform(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_colorTransform",0xc8c832c8,"openfl.geom.Transform.get_colorTransform","openfl/geom/Transform.hx",47,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  47)		return this->_hx___colorTransform;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_colorTransform,return )

 ::openfl::geom::ColorTransform Transform_obj::set_colorTransform( ::openfl::geom::ColorTransform value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_colorTransform",0xa577653c,"openfl.geom.Transform.set_colorTransform","openfl/geom/Transform.hx",52,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(  54)		Bool _hx_tmp = !(this->_hx___colorTransform->_hx___equals(value,null()));
HXDLIN(  54)		if (_hx_tmp) {
HXLINE(  56)			this->_hx___colorTransform = value;
HXLINE(  58)			Bool _hx_tmp1 = hx::IsNotNull( value );
HXDLIN(  58)			if (_hx_tmp1) {
HXLINE(  60)				this->_hx___displayObject->set_alpha(value->alphaMultiplier);
            			}
HXLINE(  64)			{
HXLINE(  64)				HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___displayObject;
HXDLIN(  64)				Bool _hx_tmp2 = !(_this->_hx___renderDirty);
HXDLIN(  64)				if (_hx_tmp2) {
HXLINE(  64)					_this->_hx___renderDirty = true;
HXDLIN(  64)					::openfl::display::DisplayObject_obj::_hx___worldRenderDirty++;
            				}
            			}
            		}
HXLINE(  68)		return this->_hx___colorTransform;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_colorTransform,return )

 ::openfl::geom::Matrix Transform_obj::get_concatenatedMatrix(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_concatenatedMatrix",0x352d276f,"openfl.geom.Transform.get_concatenatedMatrix","openfl/geom/Transform.hx",73,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  75)		Bool _hx_tmp = this->_hx___hasMatrix;
HXDLIN(  75)		if (_hx_tmp) {
HXLINE(  77)			return this->_hx___displayObject->_hx___getWorldTransform()->clone();
            		}
HXLINE(  81)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_concatenatedMatrix,return )

 ::openfl::geom::Matrix Transform_obj::get_matrix(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_matrix",0x80c3ba80,"openfl.geom.Transform.get_matrix","openfl/geom/Transform.hx",86,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  88)		Bool _hx_tmp = this->_hx___hasMatrix;
HXDLIN(  88)		if (_hx_tmp) {
HXLINE(  90)			return this->_hx___displayObject->_hx___transform->clone();
            		}
HXLINE(  94)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_matrix,return )

 ::openfl::geom::Matrix Transform_obj::set_matrix( ::openfl::geom::Matrix value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_matrix",0x844158f4,"openfl.geom.Transform.set_matrix","openfl/geom/Transform.hx",99,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 101)		Bool _hx_tmp = hx::IsNull( value );
HXDLIN( 101)		if (_hx_tmp) {
HXLINE( 103)			this->_hx___hasMatrix = false;
HXLINE( 104)			return null();
            		}
HXLINE( 108)		this->_hx___hasMatrix = true;
HXLINE( 109)		this->_hx___hasMatrix3D = false;
HXLINE( 111)		Bool _hx_tmp1 = hx::IsNotNull( this->_hx___displayObject );
HXDLIN( 111)		if (_hx_tmp1) {
HXLINE( 113)			Float _hx_tmp2 = ((Float)(int)180 / (Float)::Math_obj::PI);
HXDLIN( 113)			Float _hx_tmp3 = ::Math_obj::atan2(value->d,value->c);
HXDLIN( 113)			HX_VARI( Float,rotation) = ((_hx_tmp2 * _hx_tmp3) - (int)90);
HXLINE( 115)			Bool _hx_tmp4 = (rotation != this->_hx___displayObject->_hx___rotation);
HXDLIN( 115)			if (_hx_tmp4) {
HXLINE( 117)				this->_hx___displayObject->_hx___rotation = rotation;
HXLINE( 118)				HX_VARI( Float,radians) = (rotation * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 119)				this->_hx___displayObject->_hx___rotationSine = ::Math_obj::sin(radians);
HXLINE( 120)				this->_hx___displayObject->_hx___rotationCosine = ::Math_obj::cos(radians);
            			}
HXLINE( 124)			this->_hx___displayObject->_hx___transform->copyFrom(value);
HXLINE( 125)			{
HXLINE( 125)				HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___displayObject;
HXDLIN( 125)				Bool _hx_tmp5 = !(_this->_hx___transformDirty);
HXDLIN( 125)				if (_hx_tmp5) {
HXLINE( 125)					_this->_hx___transformDirty = true;
HXDLIN( 125)					::openfl::display::DisplayObject_obj::_hx___worldTransformDirty++;
            				}
            			}
            		}
HXLINE( 129)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_matrix,return )

 ::openfl::geom::Matrix3D Transform_obj::get_matrix3D(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_matrix3D",0x05078731,"openfl.geom.Transform.get_matrix3D","openfl/geom/Transform.hx",134,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE( 136)		Bool _hx_tmp = this->_hx___hasMatrix3D;
HXDLIN( 136)		if (_hx_tmp) {
HXLINE( 138)			HX_VARI(  ::openfl::geom::Matrix,matrix) = this->_hx___displayObject->_hx___transform;
HXLINE( 139)			HX_VARI( ::Array< Float >,a) = ::Array_obj< Float >::__new(16)->init(0,matrix->a)->init(1,matrix->b)->init(2,((Float)0.0))->init(3,((Float)0.0))->init(4,matrix->c)->init(5,matrix->d)->init(6,((Float)0.0))->init(7,((Float)0.0))->init(8,((Float)0.0))->init(9,((Float)0.0))->init(10,((Float)1.0))->init(11,((Float)0.0))->init(12,matrix->tx)->init(13,matrix->ty)->init(14,((Float)0.0))->init(15,((Float)1.0));
HXDLIN( 139)			Int length = null();
HXDLIN( 139)			Bool fixed = null();
HXDLIN( 139)			HX_VARI(  ::openfl::_Vector::FloatVector,vector) =  ::openfl::_Vector::FloatVector_obj::__new(length,fixed,null());
HXDLIN( 139)			{
HXLINE( 139)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 139)				HX_VARI( Int,_g) = a->length;
HXDLIN( 139)				while((_g1 < _g)){
HXLINE( 139)					HX_VARI( Int,i) = _g1++;
HXDLIN( 139)					vector->set(i,a->__get(i));
            				}
            			}
HXDLIN( 139)			return  ::openfl::geom::Matrix3D_obj::__new(vector);
            		}
HXLINE( 143)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_matrix3D,return )

 ::openfl::geom::Matrix3D Transform_obj::set_matrix3D( ::openfl::geom::Matrix3D value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_matrix3D",0x1a00aaa5,"openfl.geom.Transform.set_matrix3D","openfl/geom/Transform.hx",148,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 150)		Bool _hx_tmp = hx::IsNull( value );
HXDLIN( 150)		if (_hx_tmp) {
HXLINE( 152)			this->_hx___hasMatrix3D = false;
HXLINE( 153)			return null();
            		}
HXLINE( 157)		this->_hx___hasMatrix = false;
HXLINE( 158)		this->_hx___hasMatrix3D = true;
HXLINE( 160)		Bool _hx_tmp1 = hx::IsNotNull( this->_hx___displayObject );
HXDLIN( 160)		if (_hx_tmp1) {
HXLINE( 162)			Float _hx_tmp2 = ((Float)(int)180 / (Float)::Math_obj::PI);
HXDLIN( 162)			Float _hx_tmp3 = ::Math_obj::atan2(value->rawData->get((int)5),value->rawData->get((int)4));
HXDLIN( 162)			HX_VARI( Float,rotation) = ((_hx_tmp2 * _hx_tmp3) - (int)90);
HXLINE( 164)			Bool _hx_tmp4 = (rotation != this->_hx___displayObject->_hx___rotation);
HXDLIN( 164)			if (_hx_tmp4) {
HXLINE( 166)				this->_hx___displayObject->_hx___rotation = rotation;
HXLINE( 167)				HX_VARI( Float,radians) = (rotation * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 168)				this->_hx___displayObject->_hx___rotationSine = ::Math_obj::sin(radians);
HXLINE( 169)				this->_hx___displayObject->_hx___rotationCosine = ::Math_obj::cos(radians);
            			}
HXLINE( 173)			this->_hx___displayObject->_hx___transform->a = value->rawData->get((int)0);
HXLINE( 174)			this->_hx___displayObject->_hx___transform->b = value->rawData->get((int)1);
HXLINE( 175)			this->_hx___displayObject->_hx___transform->c = value->rawData->get((int)5);
HXLINE( 176)			this->_hx___displayObject->_hx___transform->d = value->rawData->get((int)6);
HXLINE( 177)			this->_hx___displayObject->_hx___transform->tx = value->rawData->get((int)12);
HXLINE( 178)			this->_hx___displayObject->_hx___transform->ty = value->rawData->get((int)13);
HXLINE( 180)			{
HXLINE( 180)				HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___displayObject;
HXDLIN( 180)				Bool _hx_tmp5 = !(_this->_hx___transformDirty);
HXDLIN( 180)				if (_hx_tmp5) {
HXLINE( 180)					_this->_hx___transformDirty = true;
HXDLIN( 180)					::openfl::display::DisplayObject_obj::_hx___worldTransformDirty++;
            				}
            			}
            		}
HXLINE( 184)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_matrix3D,return )


Transform_obj::Transform_obj()
{
}

void Transform_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Transform);
	HX_MARK_MEMBER_NAME(concatenatedColorTransform,"concatenatedColorTransform");
	HX_MARK_MEMBER_NAME(pixelBounds,"pixelBounds");
	HX_MARK_MEMBER_NAME(_hx___colorTransform,"__colorTransform");
	HX_MARK_MEMBER_NAME(_hx___displayObject,"__displayObject");
	HX_MARK_MEMBER_NAME(_hx___hasMatrix,"__hasMatrix");
	HX_MARK_MEMBER_NAME(_hx___hasMatrix3D,"__hasMatrix3D");
	HX_MARK_END_CLASS();
}

void Transform_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(concatenatedColorTransform,"concatenatedColorTransform");
	HX_VISIT_MEMBER_NAME(pixelBounds,"pixelBounds");
	HX_VISIT_MEMBER_NAME(_hx___colorTransform,"__colorTransform");
	HX_VISIT_MEMBER_NAME(_hx___displayObject,"__displayObject");
	HX_VISIT_MEMBER_NAME(_hx___hasMatrix,"__hasMatrix");
	HX_VISIT_MEMBER_NAME(_hx___hasMatrix3D,"__hasMatrix3D");
}

hx::Val Transform_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_matrix()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"matrix3D") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_matrix3D()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_matrix") ) { return hx::Val( get_matrix_dyn()); }
		if (HX_FIELD_EQ(inName,"set_matrix") ) { return hx::Val( set_matrix_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pixelBounds") ) { return hx::Val( pixelBounds); }
		if (HX_FIELD_EQ(inName,"__hasMatrix") ) { return hx::Val( _hx___hasMatrix); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_matrix3D") ) { return hx::Val( get_matrix3D_dyn()); }
		if (HX_FIELD_EQ(inName,"set_matrix3D") ) { return hx::Val( set_matrix3D_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__hasMatrix3D") ) { return hx::Val( _hx___hasMatrix3D); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_colorTransform()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__displayObject") ) { return hx::Val( _hx___displayObject); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__colorTransform") ) { return hx::Val( _hx___colorTransform); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"concatenatedMatrix") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_concatenatedMatrix()); }
		if (HX_FIELD_EQ(inName,"get_colorTransform") ) { return hx::Val( get_colorTransform_dyn()); }
		if (HX_FIELD_EQ(inName,"set_colorTransform") ) { return hx::Val( set_colorTransform_dyn()); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"get_concatenatedMatrix") ) { return hx::Val( get_concatenatedMatrix_dyn()); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"concatenatedColorTransform") ) { return hx::Val( concatenatedColorTransform); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Transform_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_matrix(inValue) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"matrix3D") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_matrix3D(inValue) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pixelBounds") ) { pixelBounds=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__hasMatrix") ) { _hx___hasMatrix=inValue.Cast< Bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__hasMatrix3D") ) { _hx___hasMatrix3D=inValue.Cast< Bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_colorTransform(inValue) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__displayObject") ) { _hx___displayObject=inValue.Cast<  ::openfl::display::DisplayObject >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__colorTransform") ) { _hx___colorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"concatenatedColorTransform") ) { concatenatedColorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Transform_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"));
	outFields->push(HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77"));
	outFields->push(HX_HCSTRING("concatenatedMatrix","\xb0","\xc0","\x9c","\xf8"));
	outFields->push(HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"));
	outFields->push(HX_HCSTRING("matrix3D","\x32","\x35","\xf3","\x66"));
	outFields->push(HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7"));
	outFields->push(HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1"));
	outFields->push(HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e"));
	outFields->push(HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a"));
	outFields->push(HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Transform_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(int)offsetof(Transform_obj,concatenatedColorTransform),HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(Transform_obj,pixelBounds),HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7")},
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(int)offsetof(Transform_obj,_hx___colorTransform),HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1")},
	{hx::fsObject /*::openfl::display::DisplayObject*/ ,(int)offsetof(Transform_obj,_hx___displayObject),HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e")},
	{hx::fsBool,(int)offsetof(Transform_obj,_hx___hasMatrix),HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a")},
	{hx::fsBool,(int)offsetof(Transform_obj,_hx___hasMatrix3D),HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Transform_obj_sStaticStorageInfo = 0;
#endif

static ::String Transform_obj_sMemberFields[] = {
	HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77"),
	HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7"),
	HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1"),
	HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e"),
	HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a"),
	HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82"),
	HX_HCSTRING("get_colorTransform","\x52","\xb8","\xd9","\x48"),
	HX_HCSTRING("set_colorTransform","\xc6","\xea","\x88","\x25"),
	HX_HCSTRING("get_concatenatedMatrix","\xf9","\x39","\x31","\x52"),
	HX_HCSTRING("get_matrix","\x0a","\xa6","\x4f","\xac"),
	HX_HCSTRING("set_matrix","\x7e","\x44","\xcd","\xaf"),
	HX_HCSTRING("get_matrix3D","\x3b","\xe9","\x0c","\x1c"),
	HX_HCSTRING("set_matrix3D","\xaf","\x0c","\x06","\x31"),
	::String(null()) };

static void Transform_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Transform_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Transform_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Transform_obj::__mClass,"__mClass");
};

#endif

hx::Class Transform_obj::__mClass;

void Transform_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.geom.Transform","\x38","\xac","\x4a","\xe3");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Transform_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Transform_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Transform_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Transform_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Transform_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Transform_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace geom

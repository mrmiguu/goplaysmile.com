// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__backend_native_NativeGLRenderContext
#include <lime/_backend/native/NativeGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLBuffer
#include <lime/graphics/opengl/GLBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractBlendModeManager
#include <openfl/_internal/renderer/AbstractBlendModeManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractFilterManager
#include <openfl/_internal/renderer/AbstractFilterManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractMaskManager
#include <openfl/_internal/renderer/AbstractMaskManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractRenderer
#include <openfl/_internal/renderer/AbstractRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractShaderManager
#include <openfl/_internal/renderer/AbstractShaderManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLRenderer
#include <openfl/_internal/renderer/opengl/GLRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLTilemap
#include <openfl/_internal/renderer/opengl/GLTilemap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderData
#include <openfl/display/ShaderData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_Tile
#include <openfl/display/Tile.h>
#endif
#ifndef INCLUDED_openfl_display_Tilemap
#include <openfl/display/Tilemap.h>
#endif
#ifndef INCLUDED_openfl_display_Tileset
#include <openfl/display/Tileset.h>
#endif
#ifndef INCLUDED_openfl_display__Tileset_TileData
#include <openfl/display/_Tileset/TileData.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{

void GLTilemap_obj::__construct() { }

Dynamic GLTilemap_obj::__CreateEmpty() { return new GLTilemap_obj; }

hx::ObjectPtr< GLTilemap_obj > GLTilemap_obj::__new()
{
	hx::ObjectPtr< GLTilemap_obj > _hx_result = new GLTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic GLTilemap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLTilemap_obj > _hx_result = new GLTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::haxe::ds::IntMap GLTilemap_obj::_hx___skippedTiles;

void GLTilemap_obj::render( ::openfl::display::Tilemap tilemap, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLTilemap","render",0xde22397f,"openfl._internal.renderer.opengl.GLTilemap.render","openfl/_internal/renderer/opengl/GLTilemap.hx",31,0xf59b2d1b)
            	HX_STACK_ARG(tilemap,"tilemap")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE(  33)		Bool _hx_tmp;
HXDLIN(  33)		Bool _hx_tmp1;
HXDLIN(  33)		if (!(!(tilemap->_hx___renderable))) {
HXLINE(  33)			_hx_tmp1 = (tilemap->_hx___tiles->length == (int)0);
            		}
            		else {
HXLINE(  33)			_hx_tmp1 = true;
            		}
HXDLIN(  33)		if (!(_hx_tmp1)) {
HXLINE(  33)			_hx_tmp = (tilemap->_hx___worldAlpha <= (int)0);
            		}
            		else {
HXLINE(  33)			_hx_tmp = true;
            		}
HXDLIN(  33)		if (_hx_tmp) {
HXLINE(  33)			return;
            		}
HXLINE(  35)		HX_VARI(  ::openfl::_internal::renderer::opengl::GLRenderer,renderer) = ( ( ::openfl::_internal::renderer::opengl::GLRenderer)(renderSession->renderer) );
HXLINE(  36)		HX_VARI(  ::lime::_backend::native::NativeGLRenderContext,gl) = renderSession->gl;
HXLINE(  38)		 ::Dynamic _hx_tmp2 = tilemap->get_blendMode();
HXDLIN(  38)		renderSession->blendModeManager->setBlendMode(_hx_tmp2);
HXLINE(  39)		renderSession->maskManager->pushObject(tilemap,null());
HXLINE(  41)		HX_VARI(  ::openfl::display::Shader,shader) = renderSession->filterManager->pushObject(tilemap);
HXLINE(  43)		HX_VARI(  ::openfl::geom::Rectangle,rect) = ::openfl::geom::Rectangle_obj::_hx___temp;
HXLINE(  44)		rect->setTo((int)0,(int)0,tilemap->_hx___width,tilemap->_hx___height);
HXLINE(  45)		renderSession->maskManager->pushRect(rect,tilemap->_hx___renderTransform);
HXLINE(  47)		shader->get_data()->uMatrix->value = renderer->getMatrix(tilemap->_hx___renderTransform);
HXLINE(  48)		Bool _hx_tmp3;
HXDLIN(  48)		if (renderSession->allowSmoothing) {
HXLINE(  48)			_hx_tmp3 = tilemap->smoothing;
            		}
            		else {
HXLINE(  48)			_hx_tmp3 = false;
            		}
HXDLIN(  48)		shader->get_data()->uImage0->smoothing = _hx_tmp3;
HXLINE(  50)		HX_VARI(  ::openfl::display::Tileset,defaultTileset) = tilemap->tileset;
HXLINE(  51)		HX_VARI( Float,worldAlpha) = tilemap->_hx___worldAlpha;
HXLINE(  52)		HX_VARI( Bool,alphaDirty) = (tilemap->_hx___worldAlpha != tilemap->_hx___cacheAlpha);
HXLINE(  54)		HX_VAR( ::Array< ::Dynamic>,tiles);
HXDLIN(  54)		HX_VAR( Int,count);
HXDLIN(  54)		HX_VAR(  ::lime::utils::ArrayBufferView,bufferData);
HXDLIN(  54)		HX_VAR( Int,startIndex);
HXDLIN(  54)		HX_VAR( Int,offset);
HXLINE(  55)		HX_VARI( Int,tileWidth) = (int)0;
HXDLIN(  55)		HX_VARI( Int,tileHeight) = (int)0;
HXLINE(  56)		HX_VAR(  ::openfl::display::Tile,tile);
HXDLIN(  56)		HX_VAR( Float,alpha);
HXDLIN(  56)		HX_VAR( Bool,visible);
HXDLIN(  56)		HX_VAR(  ::openfl::display::Tileset,tileset);
HXDLIN(  56)		HX_VAR(  ::openfl::display::_Tileset::TileData,tileData);
HXDLIN(  56)		HX_VAR(  ::openfl::geom::Matrix,tileMatrix);
HXDLIN(  56)		HX_VAR( Float,x);
HXDLIN(  56)		HX_VAR( Float,y);
HXDLIN(  56)		HX_VAR( Float,x2);
HXDLIN(  56)		HX_VAR( Float,y2);
HXDLIN(  56)		HX_VAR( Float,x3);
HXDLIN(  56)		HX_VAR( Float,y3);
HXDLIN(  56)		HX_VAR( Float,x4);
HXDLIN(  56)		HX_VAR( Float,y4);
HXLINE(  58)		tiles = tilemap->_hx___tiles;
HXLINE(  59)		count = tiles->length;
HXLINE(  61)		bufferData = tilemap->_hx___bufferData;
HXLINE(  63)		Bool _hx_tmp4;
HXDLIN(  63)		Bool _hx_tmp5;
HXDLIN(  63)		Bool _hx_tmp6 = hx::IsNotNull( bufferData );
HXDLIN(  63)		if (_hx_tmp6) {
HXLINE(  63)			_hx_tmp5 = tilemap->_hx___dirty;
            		}
            		else {
HXLINE(  63)			_hx_tmp5 = true;
            		}
HXDLIN(  63)		if (!(_hx_tmp5)) {
HXLINE(  63)			_hx_tmp4 = (bufferData->length != (count * (int)30));
            		}
            		else {
HXLINE(  63)			_hx_tmp4 = true;
            		}
HXDLIN(  63)		if (_hx_tmp4) {
HXLINE(  65)			startIndex = (int)0;
HXLINE(  67)			Bool _hx_tmp7 = hx::IsNull( bufferData );
HXDLIN(  67)			if (_hx_tmp7) {
HXLINE(  69)				HX_VARI(  ::Dynamic,elements) = (count * (int)30);
HXDLIN(  69)				HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this1,"this");
HXDLIN(  69)				Bool _hx_tmp8 = hx::IsNotNull( elements );
HXDLIN(  69)				if (_hx_tmp8) {
HXLINE(  69)					this1 =  ::lime::utils::ArrayBufferView_obj::__new(elements,(int)8);
            				}
            				else {
HXLINE(  69)					HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            				}
HXDLIN(  69)				bufferData = this1;
            			}
            			else {
HXLINE(  71)				Bool _hx_tmp9 = (bufferData->length != (count * (int)30));
HXDLIN(  71)				if (_hx_tmp9) {
HXLINE(  73)					Bool _hx_tmp10 = !(tilemap->_hx___dirty);
HXDLIN(  73)					if (_hx_tmp10) {
HXLINE(  75)						Float _hx_tmp11 = ((Float)bufferData->length / (Float)(int)30);
HXDLIN(  75)						startIndex = ::Std_obj::_hx_int(_hx_tmp11);
            					}
HXLINE(  79)					HX_VARI_NAME(  ::Dynamic,elements1,"elements") = (count * (int)30);
HXDLIN(  79)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this2,"this");
HXDLIN(  79)					Bool _hx_tmp12 = hx::IsNotNull( elements1 );
HXDLIN(  79)					if (_hx_tmp12) {
HXLINE(  79)						this2 =  ::lime::utils::ArrayBufferView_obj::__new(elements1,(int)8);
            					}
            					else {
HXLINE(  79)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
HXDLIN(  79)					HX_VARI(  ::lime::utils::ArrayBufferView,data) = this2;
HXLINE(  81)					Bool _hx_tmp13 = (bufferData->length <= data->length);
HXDLIN(  81)					if (_hx_tmp13) {
HXLINE(  83)						Bool _hx_tmp14 = hx::IsNotNull( bufferData );
HXDLIN(  83)						if (_hx_tmp14) {
HXLINE(  83)							Int _hx_tmp15 = ((int)0 * data->bytesPerElement);
HXDLIN(  83)							data->buffer->blit(_hx_tmp15,bufferData->buffer,bufferData->byteOffset,bufferData->byteLength);
            						}
            						else {
HXLINE(  83)							HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            						}
            					}
            					else {
HXLINE(  87)						HX_VARI(  ::Dynamic,end) = data->length;
HXDLIN(  87)						Bool _hx_tmp16 = hx::IsNull( end );
HXDLIN(  87)						HX_VARI( Int,len) = end;
HXDLIN(  87)						HX_VARI( Int,byte_offset) = (((int)0 * bufferData->bytesPerElement) + bufferData->byteOffset);
HXDLIN(  87)						HX_VAR(  ::lime::utils::ArrayBufferView,view);
HXDLIN(  87)						HX_VARI( Int,_g) = bufferData->type;
HXDLIN(  87)						switch((int)(_g)){
            							case (int)0: {
HXLINE(  87)								HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            							}
            							break;
            							case (int)1: {
HXLINE(  87)								HX_VARI(  ::haxe::io::Bytes,buffer) = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this3,"this");
HXDLIN(  87)								Bool _hx_tmp17 = hx::IsNotNull( buffer );
HXDLIN(  87)								if (_hx_tmp17) {
HXLINE(  87)									HX_VARI(  ::lime::utils::ArrayBufferView,_this) =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)1);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI( Int,bufferByteLength) = buffer->length;
HXDLIN(  87)									HX_VARI( Int,newByteLength) = bufferByteLength;
HXDLIN(  87)									Bool _hx_tmp18 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp18) {
HXLINE(  87)										newByteLength = (bufferByteLength - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength,_this->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength = (len * _this->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength) > bufferByteLength)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this->buffer = buffer;
HXDLIN(  87)									_this->byteOffset = byte_offset;
HXDLIN(  87)									_this->byteLength = newByteLength;
HXDLIN(  87)									Float _hx_tmp19 = ((Float)newByteLength / (Float)_this->bytesPerElement);
HXDLIN(  87)									_this->length = ::Std_obj::_hx_int(_hx_tmp19);
HXDLIN(  87)									this3 = _this;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int8Array",40,53,da,77));
            								}
HXDLIN(  87)								view = this3;
            							}
            							break;
            							case (int)2: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer1,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this4,"this");
HXDLIN(  87)								Bool _hx_tmp20 = hx::IsNotNull( buffer1 );
HXDLIN(  87)								if (_hx_tmp20) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this1,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)2);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this1->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength1,"bufferByteLength") = buffer1->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength1,"newByteLength") = bufferByteLength1;
HXDLIN(  87)									Bool _hx_tmp21 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp21) {
HXLINE(  87)										newByteLength1 = (bufferByteLength1 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength1,_this1->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength1 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength1 = (len * _this1->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength1) > bufferByteLength1)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this1->buffer = buffer1;
HXDLIN(  87)									_this1->byteOffset = byte_offset;
HXDLIN(  87)									_this1->byteLength = newByteLength1;
HXDLIN(  87)									Float _hx_tmp22 = ((Float)newByteLength1 / (Float)_this1->bytesPerElement);
HXDLIN(  87)									_this1->length = ::Std_obj::_hx_int(_hx_tmp22);
HXDLIN(  87)									this4 = _this1;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int16Array",95,b2,95,a7));
            								}
HXDLIN(  87)								view = this4;
            							}
            							break;
            							case (int)3: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer2,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this5,"this");
HXDLIN(  87)								Bool _hx_tmp23 = hx::IsNotNull( buffer2 );
HXDLIN(  87)								if (_hx_tmp23) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this2,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)3);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this2->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength2,"bufferByteLength") = buffer2->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength2,"newByteLength") = bufferByteLength2;
HXDLIN(  87)									Bool _hx_tmp24 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp24) {
HXLINE(  87)										newByteLength2 = (bufferByteLength2 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength2,_this2->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength2 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength2 = (len * _this2->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength2) > bufferByteLength2)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this2->buffer = buffer2;
HXDLIN(  87)									_this2->byteOffset = byte_offset;
HXDLIN(  87)									_this2->byteLength = newByteLength2;
HXDLIN(  87)									Float _hx_tmp25 = ((Float)newByteLength2 / (Float)_this2->bytesPerElement);
HXDLIN(  87)									_this2->length = ::Std_obj::_hx_int(_hx_tmp25);
HXDLIN(  87)									this5 = _this2;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int32Array",9b,2e,53,61));
            								}
HXDLIN(  87)								view = this5;
            							}
            							break;
            							case (int)4: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer3,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this6,"this");
HXDLIN(  87)								Bool _hx_tmp26 = hx::IsNotNull( buffer3 );
HXDLIN(  87)								if (_hx_tmp26) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this3,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)4);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this3->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength3,"bufferByteLength") = buffer3->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength3,"newByteLength") = bufferByteLength3;
HXDLIN(  87)									Bool _hx_tmp27 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp27) {
HXLINE(  87)										newByteLength3 = (bufferByteLength3 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength3,_this3->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength3 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength3 = (len * _this3->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength3) > bufferByteLength3)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this3->buffer = buffer3;
HXDLIN(  87)									_this3->byteOffset = byte_offset;
HXDLIN(  87)									_this3->byteLength = newByteLength3;
HXDLIN(  87)									Float _hx_tmp28 = ((Float)newByteLength3 / (Float)_this3->bytesPerElement);
HXDLIN(  87)									_this3->length = ::Std_obj::_hx_int(_hx_tmp28);
HXDLIN(  87)									this6 = _this3;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            								}
HXDLIN(  87)								view = this6;
            							}
            							break;
            							case (int)5: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer4,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this7,"this");
HXDLIN(  87)								Bool _hx_tmp29 = hx::IsNotNull( buffer4 );
HXDLIN(  87)								if (_hx_tmp29) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this4,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)5);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this4->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength4,"bufferByteLength") = buffer4->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength4,"newByteLength") = bufferByteLength4;
HXDLIN(  87)									Bool _hx_tmp30 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp30) {
HXLINE(  87)										newByteLength4 = (bufferByteLength4 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength4,_this4->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength4 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength4 = (len * _this4->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength4) > bufferByteLength4)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this4->buffer = buffer4;
HXDLIN(  87)									_this4->byteOffset = byte_offset;
HXDLIN(  87)									_this4->byteLength = newByteLength4;
HXDLIN(  87)									Float _hx_tmp31 = ((Float)newByteLength4 / (Float)_this4->bytesPerElement);
HXDLIN(  87)									_this4->length = ::Std_obj::_hx_int(_hx_tmp31);
HXDLIN(  87)									this7 = _this4;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8ClampedArray",8d,06,77,13));
            								}
HXDLIN(  87)								view = this7;
            							}
            							break;
            							case (int)6: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer5,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this8,"this");
HXDLIN(  87)								Bool _hx_tmp32 = hx::IsNotNull( buffer5 );
HXDLIN(  87)								if (_hx_tmp32) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this5,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)6);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this5->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength5,"bufferByteLength") = buffer5->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength5,"newByteLength") = bufferByteLength5;
HXDLIN(  87)									Bool _hx_tmp33 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp33) {
HXLINE(  87)										newByteLength5 = (bufferByteLength5 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength5,_this5->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength5 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength5 = (len * _this5->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength5) > bufferByteLength5)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this5->buffer = buffer5;
HXDLIN(  87)									_this5->byteOffset = byte_offset;
HXDLIN(  87)									_this5->byteLength = newByteLength5;
HXDLIN(  87)									Float _hx_tmp34 = ((Float)newByteLength5 / (Float)_this5->bytesPerElement);
HXDLIN(  87)									_this5->length = ::Std_obj::_hx_int(_hx_tmp34);
HXDLIN(  87)									this8 = _this5;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt16Array",0a,c7,2d,d5));
            								}
HXDLIN(  87)								view = this8;
            							}
            							break;
            							case (int)7: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer6,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this9,"this");
HXDLIN(  87)								Bool _hx_tmp35 = hx::IsNotNull( buffer6 );
HXDLIN(  87)								if (_hx_tmp35) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this6,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)7);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this6->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength6,"bufferByteLength") = buffer6->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength6,"newByteLength") = bufferByteLength6;
HXDLIN(  87)									Bool _hx_tmp36 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp36) {
HXLINE(  87)										newByteLength6 = (bufferByteLength6 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength6,_this6->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength6 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength6 = (len * _this6->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength6) > bufferByteLength6)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this6->buffer = buffer6;
HXDLIN(  87)									_this6->byteOffset = byte_offset;
HXDLIN(  87)									_this6->byteLength = newByteLength6;
HXDLIN(  87)									Float _hx_tmp37 = ((Float)newByteLength6 / (Float)_this6->bytesPerElement);
HXDLIN(  87)									_this6->length = ::Std_obj::_hx_int(_hx_tmp37);
HXDLIN(  87)									this9 = _this6;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt32Array",10,43,eb,8e));
            								}
HXDLIN(  87)								view = this9;
            							}
            							break;
            							case (int)8: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer7,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this10,"this");
HXDLIN(  87)								Bool _hx_tmp38 = hx::IsNotNull( buffer7 );
HXDLIN(  87)								if (_hx_tmp38) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this7,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)8);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this7->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength7,"bufferByteLength") = buffer7->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength7,"newByteLength") = bufferByteLength7;
HXDLIN(  87)									Bool _hx_tmp39 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp39) {
HXLINE(  87)										newByteLength7 = (bufferByteLength7 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength7,_this7->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength7 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength7 = (len * _this7->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength7) > bufferByteLength7)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this7->buffer = buffer7;
HXDLIN(  87)									_this7->byteOffset = byte_offset;
HXDLIN(  87)									_this7->byteLength = newByteLength7;
HXDLIN(  87)									Float _hx_tmp40 = ((Float)newByteLength7 / (Float)_this7->bytesPerElement);
HXDLIN(  87)									_this7->length = ::Std_obj::_hx_int(_hx_tmp40);
HXDLIN(  87)									this10 = _this7;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            								}
HXDLIN(  87)								view = this10;
            							}
            							break;
            							case (int)9: {
HXLINE(  87)								HX_VARI_NAME(  ::haxe::io::Bytes,buffer8,"buffer") = bufferData->buffer;
HXDLIN(  87)								HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this11,"this");
HXDLIN(  87)								Bool _hx_tmp41 = hx::IsNotNull( buffer8 );
HXDLIN(  87)								if (_hx_tmp41) {
HXLINE(  87)									HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this8,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)9);
HXDLIN(  87)									if ((byte_offset < (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									if ((hx::Mod(byte_offset,_this8->bytesPerElement) != (int)0)) {
HXLINE(  87)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  87)									HX_VARI_NAME( Int,bufferByteLength8,"bufferByteLength") = buffer8->length;
HXDLIN(  87)									HX_VARI_NAME( Int,newByteLength8,"newByteLength") = bufferByteLength8;
HXDLIN(  87)									Bool _hx_tmp42 = hx::IsNull( len );
HXDLIN(  87)									if (_hx_tmp42) {
HXLINE(  87)										newByteLength8 = (bufferByteLength8 - byte_offset);
HXDLIN(  87)										if ((hx::Mod(bufferByteLength8,_this8->bytesPerElement) != (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  87)										if ((newByteLength8 < (int)0)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  87)										newByteLength8 = (len * _this8->bytesPerElement);
HXDLIN(  87)										if (((byte_offset + newByteLength8) > bufferByteLength8)) {
HXLINE(  87)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  87)									_this8->buffer = buffer8;
HXDLIN(  87)									_this8->byteOffset = byte_offset;
HXDLIN(  87)									_this8->byteLength = newByteLength8;
HXDLIN(  87)									Float _hx_tmp43 = ((Float)newByteLength8 / (Float)_this8->bytesPerElement);
HXDLIN(  87)									_this8->length = ::Std_obj::_hx_int(_hx_tmp43);
HXDLIN(  87)									this11 = _this8;
            								}
            								else {
HXLINE(  87)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float64Array",8f,de,6b,1e));
            								}
HXDLIN(  87)								view = this11;
            							}
            							break;
            						}
HXDLIN(  87)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,view1,"view") = view;
HXDLIN(  87)						Bool _hx_tmp44 = hx::IsNotNull( view1 );
HXDLIN(  87)						if (_hx_tmp44) {
HXLINE(  87)							Int _hx_tmp45 = ((int)0 * data->bytesPerElement);
HXDLIN(  87)							data->buffer->blit(_hx_tmp45,view1->buffer,view1->byteOffset,view1->byteLength);
            						}
            						else {
HXLINE(  87)							HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            						}
            					}
HXLINE(  91)					bufferData = data;
            				}
            			}
HXLINE(  95)			{
HXLINE(  95)				HX_VARI( Int,_g1) = startIndex;
HXDLIN(  95)				while((_g1 < count)){
HXLINE(  95)					HX_VARI( Int,i) = _g1++;
HXLINE(  97)					 ::openfl::display::Tile _hx_tmp46 = tiles->__get(i).StaticCast<  ::openfl::display::Tile >();
HXDLIN(  97)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileAlpha(_hx_tmp46,worldAlpha,(i * (int)30),bufferData);
HXLINE(  99)					Bool _hx_tmp47 = hx::IsNotNull( tiles->__get(i).StaticCast<  ::openfl::display::Tile >()->tileset );
HXDLIN(  99)					if (_hx_tmp47) {
HXLINE(  99)						tileset = tiles->__get(i).StaticCast<  ::openfl::display::Tile >()->tileset;
            					}
            					else {
HXLINE(  99)						tileset = tilemap->tileset;
            					}
HXLINE( 101)					Bool _hx_tmp48 = hx::IsNotNull( tileset );
HXDLIN( 101)					if (_hx_tmp48) {
HXLINE( 103)						 ::openfl::display::Tile _hx_tmp49 = tiles->__get(i).StaticCast<  ::openfl::display::Tile >();
HXDLIN( 103)						::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileUV(_hx_tmp49,tileset,(i * (int)30),bufferData);
            					}
            				}
            			}
HXLINE( 109)			tilemap->_hx___bufferData = bufferData;
            		}
HXLINE( 113)		Bool _hx_tmp50 = hx::IsNull( tilemap->_hx___buffer );
HXDLIN( 113)		if (_hx_tmp50) {
HXLINE( 115)			tilemap->_hx___buffer = gl->createBuffer();
            		}
HXLINE( 119)		gl->bindBuffer(gl->ARRAY_BUFFER,tilemap->_hx___buffer);
HXLINE( 121)		HX_VARI( Int,drawCount) = (int)0;
HXLINE( 123)		{
HXLINE( 123)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 123)			while((_g11 < count)){
HXLINE( 123)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 125)				offset = (i1 * (int)30);
HXLINE( 127)				tile = tiles->__get(i1).StaticCast<  ::openfl::display::Tile >();
HXLINE( 129)				alpha = tile->alpha;
HXLINE( 130)				visible = tile->visible;
HXLINE( 132)				Bool _hx_tmp51;
HXDLIN( 132)				if (!(!(visible))) {
HXLINE( 132)					_hx_tmp51 = (alpha <= (int)0);
            				}
            				else {
HXLINE( 132)					_hx_tmp51 = true;
            				}
HXDLIN( 132)				if (_hx_tmp51) {
HXLINE( 134)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 135)					continue;
            				}
HXLINE( 139)				Bool _hx_tmp52 = hx::IsNotNull( tile->tileset );
HXDLIN( 139)				if (_hx_tmp52) {
HXLINE( 139)					tileset = tile->tileset;
            				}
            				else {
HXLINE( 139)					tileset = defaultTileset;
            				}
HXLINE( 141)				Bool _hx_tmp53 = hx::IsNull( tileset );
HXDLIN( 141)				if (_hx_tmp53) {
HXLINE( 143)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 144)					continue;
            				}
HXLINE( 148)				tileData = tileset->_hx___data->__get(tile->id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 150)				Bool _hx_tmp54 = hx::IsNull( tileData );
HXDLIN( 150)				if (_hx_tmp54) {
HXLINE( 152)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 153)					continue;
            				}
HXLINE( 157)				tileWidth = tileData->width;
HXLINE( 158)				tileHeight = tileData->height;
HXLINE( 162)				Bool _hx_tmp55;
HXDLIN( 162)				if (!(alphaDirty)) {
HXLINE( 162)					_hx_tmp55 = tile->_hx___alphaDirty;
            				}
            				else {
HXLINE( 162)					_hx_tmp55 = true;
            				}
HXDLIN( 162)				if (_hx_tmp55) {
HXLINE( 164)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileAlpha(tile,worldAlpha,offset,bufferData);
            				}
HXLINE( 168)				Bool _hx_tmp56 = tile->_hx___sourceDirty;
HXDLIN( 168)				if (_hx_tmp56) {
HXLINE( 170)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileUV(tile,tileset,offset,bufferData);
            				}
HXLINE( 174)				Bool _hx_tmp57 = tile->_hx___transformDirty;
HXDLIN( 174)				if (_hx_tmp57) {
HXLINE( 176)					tileMatrix = tile->matrix;
HXLINE( 178)					Float _hx_tmp58 = (((int)0 * tileMatrix->a) + ((int)0 * tileMatrix->c));
HXDLIN( 178)					x = (tile->_hx___transform[(int)0] = (_hx_tmp58 + tileMatrix->tx));
HXLINE( 179)					Float _hx_tmp59 = (((int)0 * tileMatrix->b) + ((int)0 * tileMatrix->d));
HXDLIN( 179)					y = (tile->_hx___transform[(int)1] = (_hx_tmp59 + tileMatrix->ty));
HXLINE( 180)					Float _hx_tmp60 = ((tileWidth * tileMatrix->a) + ((int)0 * tileMatrix->c));
HXDLIN( 180)					x2 = (tile->_hx___transform[(int)2] = (_hx_tmp60 + tileMatrix->tx));
HXLINE( 181)					Float _hx_tmp61 = ((tileWidth * tileMatrix->b) + ((int)0 * tileMatrix->d));
HXDLIN( 181)					y2 = (tile->_hx___transform[(int)3] = (_hx_tmp61 + tileMatrix->ty));
HXLINE( 182)					Float _hx_tmp62 = (((int)0 * tileMatrix->a) + (tileHeight * tileMatrix->c));
HXDLIN( 182)					x3 = (tile->_hx___transform[(int)4] = (_hx_tmp62 + tileMatrix->tx));
HXLINE( 183)					Float _hx_tmp63 = (((int)0 * tileMatrix->b) + (tileHeight * tileMatrix->d));
HXDLIN( 183)					y3 = (tile->_hx___transform[(int)5] = (_hx_tmp63 + tileMatrix->ty));
HXLINE( 184)					Float _hx_tmp64 = ((tileWidth * tileMatrix->a) + (tileHeight * tileMatrix->c));
HXDLIN( 184)					x4 = (tile->_hx___transform[(int)6] = (_hx_tmp64 + tileMatrix->tx));
HXLINE( 185)					Float _hx_tmp65 = ((tileWidth * tileMatrix->b) + (tileHeight * tileMatrix->d));
HXDLIN( 185)					y4 = (tile->_hx___transform[(int)7] = (_hx_tmp65 + tileMatrix->ty));
HXLINE( 187)					tile->_hx___transformDirty = false;
            				}
            				else {
HXLINE( 191)					x = tile->_hx___transform->__get((int)0);
HXLINE( 192)					y = tile->_hx___transform->__get((int)1);
HXLINE( 193)					x2 = tile->_hx___transform->__get((int)2);
HXLINE( 194)					y2 = tile->_hx___transform->__get((int)3);
HXLINE( 195)					x3 = tile->_hx___transform->__get((int)4);
HXLINE( 196)					y3 = tile->_hx___transform->__get((int)5);
HXLINE( 197)					x4 = tile->_hx___transform->__get((int)6);
HXLINE( 198)					y4 = tile->_hx___transform->__get((int)7);
            				}
HXLINE( 202)				{
HXLINE( 202)					Int byteOffset = (bufferData->byteOffset + (offset * (int)4));
HXDLIN( 202)					::__hxcpp_memory_set_float(bufferData->buffer->b,byteOffset,x);
            				}
HXLINE( 203)				{
HXLINE( 203)					Int _hx_tmp66 = bufferData->byteOffset;
HXDLIN( 203)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp66 + ((offset + (int)1) * (int)4)),y);
            				}
HXLINE( 204)				{
HXLINE( 204)					Int _hx_tmp67 = bufferData->byteOffset;
HXDLIN( 204)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp67 + ((offset + (int)5) * (int)4)),x2);
            				}
HXLINE( 205)				{
HXLINE( 205)					Int _hx_tmp68 = bufferData->byteOffset;
HXDLIN( 205)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp68 + ((offset + (int)6) * (int)4)),y2);
            				}
HXLINE( 206)				{
HXLINE( 206)					Int _hx_tmp69 = bufferData->byteOffset;
HXDLIN( 206)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp69 + ((offset + (int)10) * (int)4)),x3);
            				}
HXLINE( 207)				{
HXLINE( 207)					Int _hx_tmp70 = bufferData->byteOffset;
HXDLIN( 207)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp70 + ((offset + (int)11) * (int)4)),y3);
            				}
HXLINE( 209)				{
HXLINE( 209)					Int _hx_tmp71 = bufferData->byteOffset;
HXDLIN( 209)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp71 + ((offset + (int)15) * (int)4)),x3);
            				}
HXLINE( 210)				{
HXLINE( 210)					Int _hx_tmp72 = bufferData->byteOffset;
HXDLIN( 210)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp72 + ((offset + (int)16) * (int)4)),y3);
            				}
HXLINE( 211)				{
HXLINE( 211)					Int _hx_tmp73 = bufferData->byteOffset;
HXDLIN( 211)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp73 + ((offset + (int)20) * (int)4)),x2);
            				}
HXLINE( 212)				{
HXLINE( 212)					Int _hx_tmp74 = bufferData->byteOffset;
HXDLIN( 212)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp74 + ((offset + (int)21) * (int)4)),y2);
            				}
HXLINE( 213)				{
HXLINE( 213)					Int _hx_tmp75 = bufferData->byteOffset;
HXDLIN( 213)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp75 + ((offset + (int)25) * (int)4)),x4);
            				}
HXLINE( 214)				{
HXLINE( 214)					Int _hx_tmp76 = bufferData->byteOffset;
HXDLIN( 214)					::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp76 + ((offset + (int)26) * (int)4)),y4);
            				}
HXLINE( 216)				drawCount = i1;
HXLINE( 218)				::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->set(i1,false);
            			}
            		}
HXLINE( 222)		gl->bufferData(gl->ARRAY_BUFFER,bufferData,gl->DYNAMIC_DRAW);
HXLINE( 224)		gl->vertexAttribPointer(shader->get_data()->aPosition->index,(int)2,gl->FLOAT,false,(int)20,(int)0);
HXLINE( 225)		gl->vertexAttribPointer(shader->get_data()->aTexCoord->index,(int)2,gl->FLOAT,false,(int)20,(int)8);
HXLINE( 226)		gl->vertexAttribPointer(shader->get_data()->aAlpha->index,(int)1,gl->FLOAT,false,(int)20,(int)16);
HXLINE( 228)		HX_VARI(  ::openfl::display::BitmapData,cacheBitmapData) = null();
HXLINE( 229)		HX_VARI( Int,lastIndex) = (int)0;
HXLINE( 231)		{
HXLINE( 231)			HX_VARI_NAME( Int,_g12,"_g1") = (int)0;
HXDLIN( 231)			HX_VARI_NAME( Int,_g2,"_g") = (drawCount + (int)1);
HXDLIN( 231)			while((_g12 < _g2)){
HXLINE( 231)				HX_VARI_NAME( Int,i2,"i") = _g12++;
HXLINE( 233)				 ::Dynamic _hx_tmp77 = ::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->get(i2);
HXDLIN( 233)				if (_hx_tmp77) {
HXLINE( 235)					continue;
            				}
HXLINE( 239)				tile = tiles->__get(i2).StaticCast<  ::openfl::display::Tile >();
HXLINE( 240)				Bool _hx_tmp78 = hx::IsNotNull( tile->tileset );
HXDLIN( 240)				if (_hx_tmp78) {
HXLINE( 240)					tileset = tile->tileset;
            				}
            				else {
HXLINE( 240)					tileset = defaultTileset;
            				}
HXLINE( 242)				if (hx::IsNotEq( tileset->bitmapData,cacheBitmapData )) {
HXLINE( 244)					Bool _hx_tmp79 = hx::IsNotNull( cacheBitmapData );
HXDLIN( 244)					if (_hx_tmp79) {
HXLINE( 246)						shader->get_data()->uImage0->input = cacheBitmapData;
HXLINE( 247)						renderSession->shaderManager->setShader(shader);
HXLINE( 249)						Int _hx_tmp80 = gl->TRIANGLES;
HXDLIN( 249)						gl->drawArrays(_hx_tmp80,(lastIndex * (int)6),((i2 - lastIndex) * (int)6));
            					}
HXLINE( 253)					cacheBitmapData = tileset->bitmapData;
HXLINE( 254)					lastIndex = i2;
            				}
HXLINE( 258)				Bool _hx_tmp81;
HXDLIN( 258)				if ((i2 == drawCount)) {
HXLINE( 258)					_hx_tmp81 = hx::IsNotNull( tileset->bitmapData );
            				}
            				else {
HXLINE( 258)					_hx_tmp81 = false;
            				}
HXDLIN( 258)				if (_hx_tmp81) {
HXLINE( 260)					shader->get_data()->uImage0->input = tileset->bitmapData;
HXLINE( 261)					renderSession->shaderManager->setShader(shader);
HXLINE( 263)					Int _hx_tmp82 = gl->TRIANGLES;
HXDLIN( 263)					gl->drawArrays(_hx_tmp82,(lastIndex * (int)6),(((i2 + (int)1) - lastIndex) * (int)6));
            				}
            			}
            		}
HXLINE( 269)		gl->disableVertexAttribArray(shader->get_data()->aAlpha->index);
HXLINE( 271)		tilemap->_hx___dirty = false;
HXLINE( 272)		tilemap->_hx___cacheAlpha = worldAlpha;
HXLINE( 274)		renderSession->filterManager->popObject(tilemap);
HXLINE( 275)		renderSession->maskManager->popRect();
HXLINE( 276)		renderSession->maskManager->popObject(tilemap,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,render,(void))

void GLTilemap_obj::_hx___skipTile( ::openfl::display::Tile tile,Int i,Int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLTilemap","__skipTile",0x426fc316,"openfl._internal.renderer.opengl.GLTilemap.__skipTile","openfl/_internal/renderer/opengl/GLTilemap.hx",281,0xf59b2d1b)
            	HX_STACK_ARG(tile,"tile")
            	HX_STACK_ARG(i,"i")
            	HX_STACK_ARG(tileOffset,"tileOffset")
            	HX_STACK_ARG(bufferData,"bufferData")
HXLINE( 283)		HX_VARI_NAME( Int,tileOffset1,"tileOffset") = (i * (int)30);
HXLINE( 285)		{
HXLINE( 285)			Int _hx_tmp = bufferData->byteOffset;
HXDLIN( 285)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp + ((tileOffset1 + (int)4) * (int)4)),(int)0);
            		}
HXLINE( 286)		{
HXLINE( 286)			Int _hx_tmp1 = bufferData->byteOffset;
HXDLIN( 286)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp1 + ((tileOffset1 + (int)9) * (int)4)),(int)0);
            		}
HXLINE( 287)		{
HXLINE( 287)			Int _hx_tmp2 = bufferData->byteOffset;
HXDLIN( 287)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp2 + ((tileOffset1 + (int)14) * (int)4)),(int)0);
            		}
HXLINE( 288)		{
HXLINE( 288)			Int _hx_tmp3 = bufferData->byteOffset;
HXDLIN( 288)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp3 + ((tileOffset1 + (int)19) * (int)4)),(int)0);
            		}
HXLINE( 289)		{
HXLINE( 289)			Int _hx_tmp4 = bufferData->byteOffset;
HXDLIN( 289)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp4 + ((tileOffset1 + (int)24) * (int)4)),(int)0);
            		}
HXLINE( 290)		{
HXLINE( 290)			Int _hx_tmp5 = bufferData->byteOffset;
HXDLIN( 290)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp5 + ((tileOffset1 + (int)29) * (int)4)),(int)0);
            		}
HXLINE( 292)		::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->set(i,true);
HXLINE( 293)		tile->_hx___alphaDirty = true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___skipTile,(void))

void GLTilemap_obj::_hx___updateTileAlpha( ::openfl::display::Tile tile,Float worldAlpha,Int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLTilemap","__updateTileAlpha",0x6bbd875e,"openfl._internal.renderer.opengl.GLTilemap.__updateTileAlpha","openfl/_internal/renderer/opengl/GLTilemap.hx",298,0xf59b2d1b)
            	HX_STACK_ARG(tile,"tile")
            	HX_STACK_ARG(worldAlpha,"worldAlpha")
            	HX_STACK_ARG(tileOffset,"tileOffset")
            	HX_STACK_ARG(bufferData,"bufferData")
HXLINE( 300)		HX_VARI( Float,alpha) = (worldAlpha * tile->alpha);
HXLINE( 302)		{
HXLINE( 302)			Int _hx_tmp = bufferData->byteOffset;
HXDLIN( 302)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp + ((tileOffset + (int)4) * (int)4)),alpha);
            		}
HXLINE( 303)		{
HXLINE( 303)			Int _hx_tmp1 = bufferData->byteOffset;
HXDLIN( 303)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp1 + ((tileOffset + (int)9) * (int)4)),alpha);
            		}
HXLINE( 304)		{
HXLINE( 304)			Int _hx_tmp2 = bufferData->byteOffset;
HXDLIN( 304)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp2 + ((tileOffset + (int)14) * (int)4)),alpha);
            		}
HXLINE( 305)		{
HXLINE( 305)			Int _hx_tmp3 = bufferData->byteOffset;
HXDLIN( 305)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp3 + ((tileOffset + (int)19) * (int)4)),alpha);
            		}
HXLINE( 306)		{
HXLINE( 306)			Int _hx_tmp4 = bufferData->byteOffset;
HXDLIN( 306)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp4 + ((tileOffset + (int)24) * (int)4)),alpha);
            		}
HXLINE( 307)		{
HXLINE( 307)			Int _hx_tmp5 = bufferData->byteOffset;
HXDLIN( 307)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp5 + ((tileOffset + (int)29) * (int)4)),alpha);
            		}
HXLINE( 309)		tile->_hx___alphaDirty = false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___updateTileAlpha,(void))

void GLTilemap_obj::_hx___updateTileUV( ::openfl::display::Tile tile, ::openfl::display::Tileset tileset,Int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLTilemap","__updateTileUV",0xdacd8641,"openfl._internal.renderer.opengl.GLTilemap.__updateTileUV","openfl/_internal/renderer/opengl/GLTilemap.hx",314,0xf59b2d1b)
            	HX_STACK_ARG(tile,"tile")
            	HX_STACK_ARG(tileset,"tileset")
            	HX_STACK_ARG(tileOffset,"tileOffset")
            	HX_STACK_ARG(bufferData,"bufferData")
HXLINE( 316)		HX_VARI(  ::openfl::display::_Tileset::TileData,tileData) = tileset->_hx___data->__get(tile->id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 318)		Bool _hx_tmp = hx::IsNull( tileData );
HXDLIN( 318)		if (_hx_tmp) {
HXLINE( 318)			return;
            		}
HXLINE( 320)		HX_VARI( Float,x) = tileData->_hx___uvX;
HXLINE( 321)		HX_VARI( Float,y) = tileData->_hx___uvY;
HXLINE( 322)		HX_VARI( Float,x2) = tileData->_hx___uvWidth;
HXLINE( 323)		HX_VARI( Float,y2) = tileData->_hx___uvHeight;
HXLINE( 325)		{
HXLINE( 325)			Int _hx_tmp1 = bufferData->byteOffset;
HXDLIN( 325)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp1 + ((tileOffset + (int)2) * (int)4)),x);
            		}
HXLINE( 326)		{
HXLINE( 326)			Int _hx_tmp2 = bufferData->byteOffset;
HXDLIN( 326)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp2 + ((tileOffset + (int)3) * (int)4)),y);
            		}
HXLINE( 327)		{
HXLINE( 327)			Int _hx_tmp3 = bufferData->byteOffset;
HXDLIN( 327)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp3 + ((tileOffset + (int)7) * (int)4)),x2);
            		}
HXLINE( 328)		{
HXLINE( 328)			Int _hx_tmp4 = bufferData->byteOffset;
HXDLIN( 328)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp4 + ((tileOffset + (int)8) * (int)4)),y);
            		}
HXLINE( 329)		{
HXLINE( 329)			Int _hx_tmp5 = bufferData->byteOffset;
HXDLIN( 329)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp5 + ((tileOffset + (int)12) * (int)4)),x);
            		}
HXLINE( 330)		{
HXLINE( 330)			Int _hx_tmp6 = bufferData->byteOffset;
HXDLIN( 330)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp6 + ((tileOffset + (int)13) * (int)4)),y2);
            		}
HXLINE( 332)		{
HXLINE( 332)			Int _hx_tmp7 = bufferData->byteOffset;
HXDLIN( 332)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp7 + ((tileOffset + (int)17) * (int)4)),x);
            		}
HXLINE( 333)		{
HXLINE( 333)			Int _hx_tmp8 = bufferData->byteOffset;
HXDLIN( 333)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp8 + ((tileOffset + (int)18) * (int)4)),y2);
            		}
HXLINE( 334)		{
HXLINE( 334)			Int _hx_tmp9 = bufferData->byteOffset;
HXDLIN( 334)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp9 + ((tileOffset + (int)22) * (int)4)),x2);
            		}
HXLINE( 335)		{
HXLINE( 335)			Int _hx_tmp10 = bufferData->byteOffset;
HXDLIN( 335)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp10 + ((tileOffset + (int)23) * (int)4)),y);
            		}
HXLINE( 336)		{
HXLINE( 336)			Int _hx_tmp11 = bufferData->byteOffset;
HXDLIN( 336)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp11 + ((tileOffset + (int)27) * (int)4)),x2);
            		}
HXLINE( 337)		{
HXLINE( 337)			Int _hx_tmp12 = bufferData->byteOffset;
HXDLIN( 337)			::__hxcpp_memory_set_float(bufferData->buffer->b,(_hx_tmp12 + ((tileOffset + (int)28) * (int)4)),y2);
            		}
HXLINE( 339)		tile->_hx___sourceDirty = false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___updateTileUV,(void))


GLTilemap_obj::GLTilemap_obj()
{
}

bool GLTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__skipTile") ) { outValue = _hx___skipTile_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__skippedTiles") ) { outValue = _hx___skippedTiles; return true; }
		if (HX_FIELD_EQ(inName,"__updateTileUV") ) { outValue = _hx___updateTileUV_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__updateTileAlpha") ) { outValue = _hx___updateTileAlpha_dyn(); return true; }
	}
	return false;
}

bool GLTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"__skippedTiles") ) { _hx___skippedTiles=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *GLTilemap_obj_sMemberStorageInfo = 0;
static hx::StaticInfo GLTilemap_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &GLTilemap_obj::_hx___skippedTiles,HX_HCSTRING("__skippedTiles","\xd5","\xfa","\xfa","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void GLTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::_hx___skippedTiles,"__skippedTiles");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::_hx___skippedTiles,"__skippedTiles");
};

#endif

hx::Class GLTilemap_obj::__mClass;

static ::String GLTilemap_obj_sStaticFields[] = {
	HX_HCSTRING("__skippedTiles","\xd5","\xfa","\xfa","\xbb"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("__skipTile","\x6d","\x2c","\x8a","\x66"),
	HX_HCSTRING("__updateTileAlpha","\xe7","\x06","\xd7","\x7f"),
	HX_HCSTRING("__updateTileUV","\x18","\xe7","\xac","\x3e"),
	::String(null())
};

void GLTilemap_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.GLTilemap","\x25","\xe7","\x07","\x88");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GLTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &GLTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = GLTilemap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GLTilemap_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< GLTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLTilemap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GLTilemap_obj::__boot()
{
{
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLTilemap","boot",0xf7b1461b,"openfl._internal.renderer.opengl.GLTilemap.boot","openfl/_internal/renderer/opengl/GLTilemap.hx",28,0xf59b2d1b)
HXLINE(  28)		_hx___skippedTiles =  ::haxe::ds::IntMap_obj::__new();
            	}
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl

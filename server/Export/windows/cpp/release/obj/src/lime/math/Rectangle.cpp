// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_lime_math_Matrix3
#include <lime/math/Matrix3.h>
#endif
#ifndef INCLUDED_lime_math_Rectangle
#include <lime/math/Rectangle.h>
#endif
#ifndef INCLUDED_lime_math_Vector2
#include <lime/math/Vector2.h>
#endif

namespace lime{
namespace math{

void Rectangle_obj::__construct(hx::Null< Float >  __o_x,hx::Null< Float >  __o_y,hx::Null< Float >  __o_width,hx::Null< Float >  __o_height){
Float x = __o_x.Default(0);
Float y = __o_y.Default(0);
Float width = __o_width.Default(0);
Float height = __o_height.Default(0);
            	HX_STACK_FRAME("lime.math.Rectangle","new",0xb4aa4114,"lime.math.Rectangle.new","lime/math/Rectangle.hx",30,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
HXLINE(  32)		this->x = x;
HXLINE(  33)		this->y = y;
HXLINE(  34)		this->width = width;
HXLINE(  35)		this->height = height;
            	}

Dynamic Rectangle_obj::__CreateEmpty() { return new Rectangle_obj; }

hx::ObjectPtr< Rectangle_obj > Rectangle_obj::__new(hx::Null< Float >  __o_x,hx::Null< Float >  __o_y,hx::Null< Float >  __o_width,hx::Null< Float >  __o_height)
{
	hx::ObjectPtr< Rectangle_obj > _hx_result = new Rectangle_obj();
	_hx_result->__construct(__o_x,__o_y,__o_width,__o_height);
	return _hx_result;
}

Dynamic Rectangle_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Rectangle_obj > _hx_result = new Rectangle_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

 ::lime::math::Rectangle Rectangle_obj::clone(){
            	HX_STACK_FRAME("lime.math.Rectangle","clone",0x93be1911,"lime.math.Rectangle.clone","lime/math/Rectangle.hx",42,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE(  42)		return  ::lime::math::Rectangle_obj::__new(this->x,this->y,this->width,this->height);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,clone,return )

Bool Rectangle_obj::contains(Float x,Float y){
            	HX_STACK_FRAME("lime.math.Rectangle","contains",0xf10bdceb,"lime.math.Rectangle.contains","lime/math/Rectangle.hx",49,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE(  49)		Bool _hx_tmp;
HXDLIN(  49)		Bool _hx_tmp1;
HXDLIN(  49)		if ((x >= this->x)) {
HXLINE(  49)			_hx_tmp1 = (y >= this->y);
            		}
            		else {
HXLINE(  49)			_hx_tmp1 = false;
            		}
HXDLIN(  49)		if (_hx_tmp1) {
HXLINE(  49)			Float _hx_tmp2 = this->get_right();
HXDLIN(  49)			_hx_tmp = (x < _hx_tmp2);
            		}
            		else {
HXLINE(  49)			_hx_tmp = false;
            		}
HXDLIN(  49)		if (_hx_tmp) {
HXLINE(  49)			Float _hx_tmp3 = this->get_bottom();
HXDLIN(  49)			return (y < _hx_tmp3);
            		}
            		else {
HXLINE(  49)			return false;
            		}
HXDLIN(  49)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Rectangle_obj,contains,return )

Bool Rectangle_obj::containsPoint( ::lime::math::Vector2 point){
            	HX_STACK_FRAME("lime.math.Rectangle","containsPoint",0x3a119365,"lime.math.Rectangle.containsPoint","lime/math/Rectangle.hx",56,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(point,"point")
HXLINE(  56)		return this->contains(point->x,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,containsPoint,return )

Bool Rectangle_obj::containsRect( ::lime::math::Rectangle rect){
            	HX_STACK_FRAME("lime.math.Rectangle","containsRect",0x7fd4a7af,"lime.math.Rectangle.containsRect","lime/math/Rectangle.hx",63,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(rect,"rect")
HXLINE(  63)		Bool _hx_tmp;
HXDLIN(  63)		if (!((rect->width <= (int)0))) {
HXLINE(  63)			_hx_tmp = (rect->height <= (int)0);
            		}
            		else {
HXLINE(  63)			_hx_tmp = true;
            		}
HXDLIN(  63)		if (_hx_tmp) {
HXLINE(  65)			Bool _hx_tmp1;
HXDLIN(  65)			Bool _hx_tmp2;
HXDLIN(  65)			if ((rect->x > this->x)) {
HXLINE(  65)				_hx_tmp2 = (rect->y > this->y);
            			}
            			else {
HXLINE(  65)				_hx_tmp2 = false;
            			}
HXDLIN(  65)			if (_hx_tmp2) {
HXLINE(  65)				Float _hx_tmp3 = rect->get_right();
HXDLIN(  65)				Float _hx_tmp4 = this->get_right();
HXDLIN(  65)				_hx_tmp1 = (_hx_tmp3 < _hx_tmp4);
            			}
            			else {
HXLINE(  65)				_hx_tmp1 = false;
            			}
HXDLIN(  65)			if (_hx_tmp1) {
HXLINE(  65)				Float _hx_tmp5 = rect->get_bottom();
HXDLIN(  65)				Float _hx_tmp6 = this->get_bottom();
HXDLIN(  65)				return (_hx_tmp5 < _hx_tmp6);
            			}
            			else {
HXLINE(  65)				return false;
            			}
            		}
            		else {
HXLINE(  69)			Bool _hx_tmp7;
HXDLIN(  69)			Bool _hx_tmp8;
HXDLIN(  69)			if ((rect->x >= this->x)) {
HXLINE(  69)				_hx_tmp8 = (rect->y >= this->y);
            			}
            			else {
HXLINE(  69)				_hx_tmp8 = false;
            			}
HXDLIN(  69)			if (_hx_tmp8) {
HXLINE(  69)				Float _hx_tmp9 = rect->get_right();
HXDLIN(  69)				Float _hx_tmp10 = this->get_right();
HXDLIN(  69)				_hx_tmp7 = (_hx_tmp9 <= _hx_tmp10);
            			}
            			else {
HXLINE(  69)				_hx_tmp7 = false;
            			}
HXDLIN(  69)			if (_hx_tmp7) {
HXLINE(  69)				Float _hx_tmp11 = rect->get_bottom();
HXDLIN(  69)				Float _hx_tmp12 = this->get_bottom();
HXDLIN(  69)				return (_hx_tmp11 <= _hx_tmp12);
            			}
            			else {
HXLINE(  69)				return false;
            			}
            		}
HXLINE(  63)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,containsRect,return )

void Rectangle_obj::copyFrom( ::lime::math::Rectangle sourceRect){
            	HX_STACK_FRAME("lime.math.Rectangle","copyFrom",0x8cf18e8b,"lime.math.Rectangle.copyFrom","lime/math/Rectangle.hx",76,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(sourceRect,"sourceRect")
HXLINE(  78)		this->x = sourceRect->x;
HXLINE(  79)		this->y = sourceRect->y;
HXLINE(  80)		this->width = sourceRect->width;
HXLINE(  81)		this->height = sourceRect->height;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,copyFrom,(void))

Bool Rectangle_obj::equals( ::lime::math::Rectangle toCompare){
            	HX_STACK_FRAME("lime.math.Rectangle","equals",0x643ce60b,"lime.math.Rectangle.equals","lime/math/Rectangle.hx",88,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(toCompare,"toCompare")
HXLINE(  88)		Bool _hx_tmp;
HXDLIN(  88)		Bool _hx_tmp1;
HXDLIN(  88)		Bool _hx_tmp2;
HXDLIN(  88)		Bool _hx_tmp3 = hx::IsNotNull( toCompare );
HXDLIN(  88)		if (_hx_tmp3) {
HXLINE(  88)			_hx_tmp2 = (this->x == toCompare->x);
            		}
            		else {
HXLINE(  88)			_hx_tmp2 = false;
            		}
HXDLIN(  88)		if (_hx_tmp2) {
HXLINE(  88)			_hx_tmp1 = (this->y == toCompare->y);
            		}
            		else {
HXLINE(  88)			_hx_tmp1 = false;
            		}
HXDLIN(  88)		if (_hx_tmp1) {
HXLINE(  88)			_hx_tmp = (this->width == toCompare->width);
            		}
            		else {
HXLINE(  88)			_hx_tmp = false;
            		}
HXDLIN(  88)		if (_hx_tmp) {
HXLINE(  88)			return (this->height == toCompare->height);
            		}
            		else {
HXLINE(  88)			return false;
            		}
HXDLIN(  88)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,equals,return )

void Rectangle_obj::inflate(Float dx,Float dy){
            	HX_STACK_FRAME("lime.math.Rectangle","inflate",0x288a773b,"lime.math.Rectangle.inflate","lime/math/Rectangle.hx",93,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(dx,"dx")
            	HX_STACK_ARG(dy,"dy")
HXLINE(  95)		hx::SubEq(this->x,dx);
HXDLIN(  95)		hx::AddEq(this->width,(dx * (int)2));
HXLINE(  96)		hx::SubEq(this->y,dy);
HXDLIN(  96)		hx::AddEq(this->height,(dy * (int)2));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Rectangle_obj,inflate,(void))

void Rectangle_obj::inflatePoint( ::lime::math::Vector2 point){
            	HX_STACK_FRAME("lime.math.Rectangle","inflatePoint",0x0bf19715,"lime.math.Rectangle.inflatePoint","lime/math/Rectangle.hx",103,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(point,"point")
HXLINE( 103)		this->inflate(point->x,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,inflatePoint,(void))

 ::lime::math::Rectangle Rectangle_obj::intersection( ::lime::math::Rectangle toIntersect){
            	HX_STACK_FRAME("lime.math.Rectangle","intersection",0x62197b15,"lime.math.Rectangle.intersection","lime/math/Rectangle.hx",108,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(toIntersect,"toIntersect")
HXLINE( 110)		HX_VAR( Float,x0);
HXDLIN( 110)		if ((this->x < toIntersect->x)) {
HXLINE( 110)			x0 = toIntersect->x;
            		}
            		else {
HXLINE( 110)			x0 = this->x;
            		}
HXLINE( 111)		HX_VAR( Float,x1);
HXDLIN( 111)		Float _hx_tmp = this->get_right();
HXDLIN( 111)		Float _hx_tmp1 = toIntersect->get_right();
HXDLIN( 111)		if ((_hx_tmp > _hx_tmp1)) {
HXLINE( 111)			x1 = toIntersect->get_right();
            		}
            		else {
HXLINE( 111)			x1 = this->get_right();
            		}
HXLINE( 113)		if ((x1 <= x0)) {
HXLINE( 115)			return  ::lime::math::Rectangle_obj::__new(null(),null(),null(),null());
            		}
HXLINE( 119)		HX_VAR( Float,y0);
HXDLIN( 119)		if ((this->y < toIntersect->y)) {
HXLINE( 119)			y0 = toIntersect->y;
            		}
            		else {
HXLINE( 119)			y0 = this->y;
            		}
HXLINE( 120)		HX_VAR( Float,y1);
HXDLIN( 120)		Float _hx_tmp2 = this->get_bottom();
HXDLIN( 120)		Float _hx_tmp3 = toIntersect->get_bottom();
HXDLIN( 120)		if ((_hx_tmp2 > _hx_tmp3)) {
HXLINE( 120)			y1 = toIntersect->get_bottom();
            		}
            		else {
HXLINE( 120)			y1 = this->get_bottom();
            		}
HXLINE( 122)		if ((y1 <= y0)) {
HXLINE( 124)			return  ::lime::math::Rectangle_obj::__new(null(),null(),null(),null());
            		}
HXLINE( 128)		return  ::lime::math::Rectangle_obj::__new(x0,y0,(x1 - x0),(y1 - y0));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,intersection,return )

Bool Rectangle_obj::intersects( ::lime::math::Rectangle toIntersect){
            	HX_STACK_FRAME("lime.math.Rectangle","intersects",0x4fbb9080,"lime.math.Rectangle.intersects","lime/math/Rectangle.hx",133,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(toIntersect,"toIntersect")
HXLINE( 135)		HX_VAR( Float,x0);
HXDLIN( 135)		if ((this->x < toIntersect->x)) {
HXLINE( 135)			x0 = toIntersect->x;
            		}
            		else {
HXLINE( 135)			x0 = this->x;
            		}
HXLINE( 136)		HX_VAR( Float,x1);
HXDLIN( 136)		Float _hx_tmp = this->get_right();
HXDLIN( 136)		Float _hx_tmp1 = toIntersect->get_right();
HXDLIN( 136)		if ((_hx_tmp > _hx_tmp1)) {
HXLINE( 136)			x1 = toIntersect->get_right();
            		}
            		else {
HXLINE( 136)			x1 = this->get_right();
            		}
HXLINE( 138)		if ((x1 <= x0)) {
HXLINE( 140)			return false;
            		}
HXLINE( 144)		HX_VAR( Float,y0);
HXDLIN( 144)		if ((this->y < toIntersect->y)) {
HXLINE( 144)			y0 = toIntersect->y;
            		}
            		else {
HXLINE( 144)			y0 = this->y;
            		}
HXLINE( 145)		HX_VAR( Float,y1);
HXDLIN( 145)		Float _hx_tmp2 = this->get_bottom();
HXDLIN( 145)		Float _hx_tmp3 = toIntersect->get_bottom();
HXDLIN( 145)		if ((_hx_tmp2 > _hx_tmp3)) {
HXLINE( 145)			y1 = toIntersect->get_bottom();
            		}
            		else {
HXLINE( 145)			y1 = this->get_bottom();
            		}
HXLINE( 147)		return (y1 > y0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,intersects,return )

Bool Rectangle_obj::isEmpty(){
            	HX_STACK_FRAME("lime.math.Rectangle","isEmpty",0x28ceb8f7,"lime.math.Rectangle.isEmpty","lime/math/Rectangle.hx",154,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 154)		if (!((this->width <= (int)0))) {
HXLINE( 154)			return (this->height <= (int)0);
            		}
            		else {
HXLINE( 154)			return true;
            		}
HXDLIN( 154)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,isEmpty,return )

void Rectangle_obj::offset(Float dx,Float dy){
            	HX_STACK_FRAME("lime.math.Rectangle","offset",0x04898f5f,"lime.math.Rectangle.offset","lime/math/Rectangle.hx",159,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(dx,"dx")
            	HX_STACK_ARG(dy,"dy")
HXLINE( 161)		hx::AddEq(this->x,dx);
HXLINE( 162)		hx::AddEq(this->y,dy);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Rectangle_obj,offset,(void))

void Rectangle_obj::offsetPoint( ::lime::math::Vector2 point){
            	HX_STACK_FRAME("lime.math.Rectangle","offsetPoint",0x49147c71,"lime.math.Rectangle.offsetPoint","lime/math/Rectangle.hx",167,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(point,"point")
HXLINE( 169)		hx::AddEq(this->x,point->x);
HXLINE( 170)		hx::AddEq(this->y,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,offsetPoint,(void))

void Rectangle_obj::setEmpty(){
            	HX_STACK_FRAME("lime.math.Rectangle","setEmpty",0x429f2657,"lime.math.Rectangle.setEmpty","lime/math/Rectangle.hx",177,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 177)		this->x = (this->y = (this->width = (this->height = (int)0)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,setEmpty,(void))

void Rectangle_obj::setTo(Float xa,Float ya,Float widtha,Float heighta){
            	HX_STACK_FRAME("lime.math.Rectangle","setTo",0xc58a9771,"lime.math.Rectangle.setTo","lime/math/Rectangle.hx",182,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(xa,"xa")
            	HX_STACK_ARG(ya,"ya")
            	HX_STACK_ARG(widtha,"widtha")
            	HX_STACK_ARG(heighta,"heighta")
HXLINE( 184)		this->x = xa;
HXLINE( 185)		this->y = ya;
HXLINE( 186)		this->width = widtha;
HXLINE( 187)		this->height = heighta;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Rectangle_obj,setTo,(void))

 ::lime::math::Rectangle Rectangle_obj::transform( ::lime::math::Matrix3 m){
            	HX_STACK_FRAME("lime.math.Rectangle","transform",0x7f751d20,"lime.math.Rectangle.transform","lime/math/Rectangle.hx",192,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(m,"m")
HXLINE( 194)		HX_VARI( Float,tx0) = ((m->a * this->x) + (m->c * this->y));
HXLINE( 195)		HX_VARI( Float,tx1) = tx0;
HXLINE( 196)		HX_VARI( Float,ty0) = ((m->b * this->x) + (m->d * this->y));
HXLINE( 197)		HX_VARI( Float,ty1) = ty0;
HXLINE( 199)		HX_VARI( Float,tx) = ((m->a * (this->x + this->width)) + (m->c * this->y));
HXLINE( 200)		HX_VARI( Float,ty) = ((m->b * (this->x + this->width)) + (m->d * this->y));
HXLINE( 202)		Bool _hx_tmp = (tx < tx0);
HXDLIN( 202)		if (_hx_tmp) {
HXLINE( 202)			tx0 = tx;
            		}
HXLINE( 203)		Bool _hx_tmp1 = (ty < ty0);
HXDLIN( 203)		if (_hx_tmp1) {
HXLINE( 203)			ty0 = ty;
            		}
HXLINE( 204)		Bool _hx_tmp2 = (tx > tx1);
HXDLIN( 204)		if (_hx_tmp2) {
HXLINE( 204)			tx1 = tx;
            		}
HXLINE( 205)		Bool _hx_tmp3 = (ty > ty1);
HXDLIN( 205)		if (_hx_tmp3) {
HXLINE( 205)			ty1 = ty;
            		}
HXLINE( 207)		tx = ((m->a * (this->x + this->width)) + (m->c * (this->y + this->height)));
HXLINE( 208)		ty = ((m->b * (this->x + this->width)) + (m->d * (this->y + this->height)));
HXLINE( 210)		Bool _hx_tmp4 = (tx < tx0);
HXDLIN( 210)		if (_hx_tmp4) {
HXLINE( 210)			tx0 = tx;
            		}
HXLINE( 211)		Bool _hx_tmp5 = (ty < ty0);
HXDLIN( 211)		if (_hx_tmp5) {
HXLINE( 211)			ty0 = ty;
            		}
HXLINE( 212)		Bool _hx_tmp6 = (tx > tx1);
HXDLIN( 212)		if (_hx_tmp6) {
HXLINE( 212)			tx1 = tx;
            		}
HXLINE( 213)		Bool _hx_tmp7 = (ty > ty1);
HXDLIN( 213)		if (_hx_tmp7) {
HXLINE( 213)			ty1 = ty;
            		}
HXLINE( 215)		tx = ((m->a * this->x) + (m->c * (this->y + this->height)));
HXLINE( 216)		ty = ((m->b * this->x) + (m->d * (this->y + this->height)));
HXLINE( 218)		Bool _hx_tmp8 = (tx < tx0);
HXDLIN( 218)		if (_hx_tmp8) {
HXLINE( 218)			tx0 = tx;
            		}
HXLINE( 219)		Bool _hx_tmp9 = (ty < ty0);
HXDLIN( 219)		if (_hx_tmp9) {
HXLINE( 219)			ty0 = ty;
            		}
HXLINE( 220)		Bool _hx_tmp10 = (tx > tx1);
HXDLIN( 220)		if (_hx_tmp10) {
HXLINE( 220)			tx1 = tx;
            		}
HXLINE( 221)		Bool _hx_tmp11 = (ty > ty1);
HXDLIN( 221)		if (_hx_tmp11) {
HXLINE( 221)			ty1 = ty;
            		}
HXLINE( 223)		return  ::lime::math::Rectangle_obj::__new((tx0 + m->tx),(ty0 + m->ty),(tx1 - tx0),(ty1 - ty0));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,transform,return )

 ::lime::math::Rectangle Rectangle_obj::_hx_union( ::lime::math::Rectangle toUnion){
            	HX_STACK_FRAME("lime.math.Rectangle","union",0xf2426ac3,"lime.math.Rectangle.union","lime/math/Rectangle.hx",228,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(toUnion,"toUnion")
HXLINE( 230)		Bool _hx_tmp;
HXDLIN( 230)		if ((this->width != (int)0)) {
HXLINE( 230)			_hx_tmp = (this->height == (int)0);
            		}
            		else {
HXLINE( 230)			_hx_tmp = true;
            		}
HXDLIN( 230)		if (_hx_tmp) {
HXLINE( 232)			return toUnion->clone();
            		}
            		else {
HXLINE( 234)			Bool _hx_tmp1;
HXDLIN( 234)			if ((toUnion->width != (int)0)) {
HXLINE( 234)				_hx_tmp1 = (toUnion->height == (int)0);
            			}
            			else {
HXLINE( 234)				_hx_tmp1 = true;
            			}
HXDLIN( 234)			if (_hx_tmp1) {
HXLINE( 236)				return this->clone();
            			}
            		}
HXLINE( 240)		HX_VAR( Float,x0);
HXDLIN( 240)		if ((this->x > toUnion->x)) {
HXLINE( 240)			x0 = toUnion->x;
            		}
            		else {
HXLINE( 240)			x0 = this->x;
            		}
HXLINE( 241)		HX_VAR( Float,x1);
HXDLIN( 241)		Float _hx_tmp2 = this->get_right();
HXDLIN( 241)		Float _hx_tmp3 = toUnion->get_right();
HXDLIN( 241)		if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 241)			x1 = toUnion->get_right();
            		}
            		else {
HXLINE( 241)			x1 = this->get_right();
            		}
HXLINE( 242)		HX_VAR( Float,y0);
HXDLIN( 242)		if ((this->y > toUnion->y)) {
HXLINE( 242)			y0 = toUnion->y;
            		}
            		else {
HXLINE( 242)			y0 = this->y;
            		}
HXLINE( 243)		HX_VAR( Float,y1);
HXDLIN( 243)		Float _hx_tmp4 = this->get_bottom();
HXDLIN( 243)		Float _hx_tmp5 = toUnion->get_bottom();
HXDLIN( 243)		if ((_hx_tmp4 < _hx_tmp5)) {
HXLINE( 243)			y1 = toUnion->get_bottom();
            		}
            		else {
HXLINE( 243)			y1 = this->get_bottom();
            		}
HXLINE( 245)		return  ::lime::math::Rectangle_obj::__new(x0,y0,(x1 - x0),(y1 - y0));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,_hx_union,return )

void Rectangle_obj::_hx___contract(Float x,Float y,Float width,Float height){
            	HX_STACK_FRAME("lime.math.Rectangle","__contract",0x46ba1ffe,"lime.math.Rectangle.__contract","lime/math/Rectangle.hx",250,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
HXLINE( 252)		Bool _hx_tmp;
HXDLIN( 252)		if ((this->width == (int)0)) {
HXLINE( 252)			_hx_tmp = (this->height == (int)0);
            		}
            		else {
HXLINE( 252)			_hx_tmp = false;
            		}
HXDLIN( 252)		if (_hx_tmp) {
HXLINE( 254)			return;
            		}
HXLINE( 261)		Bool _hx_tmp1 = (this->x < x);
HXDLIN( 261)		if (_hx_tmp1) {
HXLINE( 261)			this->x = x;
            		}
HXLINE( 262)		Bool _hx_tmp2 = (this->y < y);
HXDLIN( 262)		if (_hx_tmp2) {
HXLINE( 262)			this->y = y;
            		}
HXLINE( 263)		Float _hx_tmp3 = this->get_right();
HXDLIN( 263)		if ((_hx_tmp3 > (x + width))) {
HXLINE( 263)			this->width = ((x + width) - this->x);
            		}
HXLINE( 264)		Float _hx_tmp4 = this->get_bottom();
HXDLIN( 264)		if ((_hx_tmp4 > (y + height))) {
HXLINE( 264)			this->height = ((y + height) - this->y);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Rectangle_obj,_hx___contract,(void))

void Rectangle_obj::_hx___expand(Float x,Float y,Float width,Float height){
            	HX_STACK_FRAME("lime.math.Rectangle","__expand",0x3132dc46,"lime.math.Rectangle.__expand","lime/math/Rectangle.hx",269,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
HXLINE( 271)		Bool _hx_tmp;
HXDLIN( 271)		if ((this->width == (int)0)) {
HXLINE( 271)			_hx_tmp = (this->height == (int)0);
            		}
            		else {
HXLINE( 271)			_hx_tmp = false;
            		}
HXDLIN( 271)		if (_hx_tmp) {
HXLINE( 273)			this->x = x;
HXLINE( 274)			this->y = y;
HXLINE( 275)			this->width = width;
HXLINE( 276)			this->height = height;
HXLINE( 277)			return;
            		}
HXLINE( 281)		HX_VARI( Float,cacheRight) = this->get_right();
HXLINE( 282)		HX_VARI( Float,cacheBottom) = this->get_bottom();
HXLINE( 284)		Bool _hx_tmp1 = (this->x > x);
HXDLIN( 284)		if (_hx_tmp1) {
HXLINE( 284)			this->x = x;
            		}
HXLINE( 285)		Bool _hx_tmp2 = (this->y > y);
HXDLIN( 285)		if (_hx_tmp2) {
HXLINE( 285)			this->y = y;
            		}
HXLINE( 286)		if ((cacheRight < (x + width))) {
HXLINE( 286)			this->width = ((x + width) - this->x);
            		}
HXLINE( 287)		if ((cacheBottom < (y + height))) {
HXLINE( 287)			this->height = ((y + height) - this->y);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Rectangle_obj,_hx___expand,(void))

 ::Dynamic Rectangle_obj::_hx___toFlashRectangle(){
            	HX_STACK_FRAME("lime.math.Rectangle","__toFlashRectangle",0x525ed026,"lime.math.Rectangle.__toFlashRectangle","lime/math/Rectangle.hx",297,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 297)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,_hx___toFlashRectangle,return )

Float Rectangle_obj::get_bottom(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_bottom",0xc1d02480,"lime.math.Rectangle.get_bottom","lime/math/Rectangle.hx",310,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 310)		return (this->y + this->height);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_bottom,return )

Float Rectangle_obj::set_bottom(Float b){
            	HX_STACK_FRAME("lime.math.Rectangle","set_bottom",0xc54dc2f4,"lime.math.Rectangle.set_bottom","lime/math/Rectangle.hx",311,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(b,"b")
HXLINE( 311)		this->height = (b - this->y);
HXDLIN( 311)		return b;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_bottom,return )

 ::lime::math::Vector2 Rectangle_obj::get_bottomRight(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_bottomRight",0x2f6d073c,"lime.math.Rectangle.get_bottomRight","lime/math/Rectangle.hx",312,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 312)		return  ::lime::math::Vector2_obj::__new((this->x + this->width),(this->y + this->height));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_bottomRight,return )

 ::lime::math::Vector2 Rectangle_obj::set_bottomRight( ::lime::math::Vector2 p){
            	HX_STACK_FRAME("lime.math.Rectangle","set_bottomRight",0x2b388448,"lime.math.Rectangle.set_bottomRight","lime/math/Rectangle.hx",313,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(p,"p")
HXLINE( 313)		this->width = (p->x - this->x);
HXDLIN( 313)		this->height = (p->y - this->y);
HXDLIN( 313)		return p->clone();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_bottomRight,return )

Float Rectangle_obj::get_left(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_left",0x8bfb465c,"lime.math.Rectangle.get_left","lime/math/Rectangle.hx",314,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 314)		return this->x;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_left,return )

Float Rectangle_obj::set_left(Float l){
            	HX_STACK_FRAME("lime.math.Rectangle","set_left",0x3a589fd0,"lime.math.Rectangle.set_left","lime/math/Rectangle.hx",315,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(l,"l")
HXLINE( 315)		hx::SubEq(this->width,(l - this->x));
HXDLIN( 315)		this->x = l;
HXDLIN( 315)		return l;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_left,return )

Float Rectangle_obj::get_right(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_right",0x66ef57e7,"lime.math.Rectangle.get_right","lime/math/Rectangle.hx",316,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 316)		return (this->x + this->width);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_right,return )

Float Rectangle_obj::set_right(Float r){
            	HX_STACK_FRAME("lime.math.Rectangle","set_right",0x4a4043f3,"lime.math.Rectangle.set_right","lime/math/Rectangle.hx",317,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(r,"r")
HXLINE( 317)		this->width = (r - this->x);
HXDLIN( 317)		return r;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_right,return )

 ::lime::math::Vector2 Rectangle_obj::get_size(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_size",0x909edf16,"lime.math.Rectangle.get_size","lime/math/Rectangle.hx",318,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 318)		return  ::lime::math::Vector2_obj::__new(this->width,this->height);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_size,return )

 ::lime::math::Vector2 Rectangle_obj::set_size( ::lime::math::Vector2 p){
            	HX_STACK_FRAME("lime.math.Rectangle","set_size",0x3efc388a,"lime.math.Rectangle.set_size","lime/math/Rectangle.hx",319,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(p,"p")
HXLINE( 319)		this->width = p->x;
HXDLIN( 319)		this->height = p->y;
HXDLIN( 319)		return p->clone();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_size,return )

Float Rectangle_obj::get_top(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_top",0x433c09e0,"lime.math.Rectangle.get_top","lime/math/Rectangle.hx",320,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 320)		return this->y;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_top,return )

Float Rectangle_obj::set_top(Float t){
            	HX_STACK_FRAME("lime.math.Rectangle","set_top",0x363d9aec,"lime.math.Rectangle.set_top","lime/math/Rectangle.hx",321,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(t,"t")
HXLINE( 321)		hx::SubEq(this->height,(t - this->y));
HXDLIN( 321)		this->y = t;
HXDLIN( 321)		return t;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_top,return )

 ::lime::math::Vector2 Rectangle_obj::get_topLeft(){
            	HX_STACK_FRAME("lime.math.Rectangle","get_topLeft",0x58bfae07,"lime.math.Rectangle.get_topLeft","lime/math/Rectangle.hx",322,0xce0be93c)
            	HX_STACK_THIS(this)
HXLINE( 322)		return  ::lime::math::Vector2_obj::__new(this->x,this->y);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Rectangle_obj,get_topLeft,return )

 ::lime::math::Vector2 Rectangle_obj::set_topLeft( ::lime::math::Vector2 p){
            	HX_STACK_FRAME("lime.math.Rectangle","set_topLeft",0x632cb513,"lime.math.Rectangle.set_topLeft","lime/math/Rectangle.hx",323,0xce0be93c)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(p,"p")
HXLINE( 323)		this->x = p->x;
HXDLIN( 323)		this->y = p->y;
HXDLIN( 323)		return p->clone();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Rectangle_obj,set_topLeft,return )


Rectangle_obj::Rectangle_obj()
{
}

hx::Val Rectangle_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return hx::Val( x); }
		if (HX_FIELD_EQ(inName,"y") ) { return hx::Val( y); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_top()); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_left()); }
		if (HX_FIELD_EQ(inName,"size") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_size()); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"right") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_right()); }
		if (HX_FIELD_EQ(inName,"width") ) { return hx::Val( width); }
		if (HX_FIELD_EQ(inName,"clone") ) { return hx::Val( clone_dyn()); }
		if (HX_FIELD_EQ(inName,"setTo") ) { return hx::Val( setTo_dyn()); }
		if (HX_FIELD_EQ(inName,"union") ) { return hx::Val( _hx_union_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bottom") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_bottom()); }
		if (HX_FIELD_EQ(inName,"height") ) { return hx::Val( height); }
		if (HX_FIELD_EQ(inName,"equals") ) { return hx::Val( equals_dyn()); }
		if (HX_FIELD_EQ(inName,"offset") ) { return hx::Val( offset_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"topLeft") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_topLeft()); }
		if (HX_FIELD_EQ(inName,"inflate") ) { return hx::Val( inflate_dyn()); }
		if (HX_FIELD_EQ(inName,"isEmpty") ) { return hx::Val( isEmpty_dyn()); }
		if (HX_FIELD_EQ(inName,"get_top") ) { return hx::Val( get_top_dyn()); }
		if (HX_FIELD_EQ(inName,"set_top") ) { return hx::Val( set_top_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"contains") ) { return hx::Val( contains_dyn()); }
		if (HX_FIELD_EQ(inName,"copyFrom") ) { return hx::Val( copyFrom_dyn()); }
		if (HX_FIELD_EQ(inName,"setEmpty") ) { return hx::Val( setEmpty_dyn()); }
		if (HX_FIELD_EQ(inName,"__expand") ) { return hx::Val( _hx___expand_dyn()); }
		if (HX_FIELD_EQ(inName,"get_left") ) { return hx::Val( get_left_dyn()); }
		if (HX_FIELD_EQ(inName,"set_left") ) { return hx::Val( set_left_dyn()); }
		if (HX_FIELD_EQ(inName,"get_size") ) { return hx::Val( get_size_dyn()); }
		if (HX_FIELD_EQ(inName,"set_size") ) { return hx::Val( set_size_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"transform") ) { return hx::Val( transform_dyn()); }
		if (HX_FIELD_EQ(inName,"get_right") ) { return hx::Val( get_right_dyn()); }
		if (HX_FIELD_EQ(inName,"set_right") ) { return hx::Val( set_right_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"intersects") ) { return hx::Val( intersects_dyn()); }
		if (HX_FIELD_EQ(inName,"__contract") ) { return hx::Val( _hx___contract_dyn()); }
		if (HX_FIELD_EQ(inName,"get_bottom") ) { return hx::Val( get_bottom_dyn()); }
		if (HX_FIELD_EQ(inName,"set_bottom") ) { return hx::Val( set_bottom_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"bottomRight") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_bottomRight()); }
		if (HX_FIELD_EQ(inName,"offsetPoint") ) { return hx::Val( offsetPoint_dyn()); }
		if (HX_FIELD_EQ(inName,"get_topLeft") ) { return hx::Val( get_topLeft_dyn()); }
		if (HX_FIELD_EQ(inName,"set_topLeft") ) { return hx::Val( set_topLeft_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"containsRect") ) { return hx::Val( containsRect_dyn()); }
		if (HX_FIELD_EQ(inName,"inflatePoint") ) { return hx::Val( inflatePoint_dyn()); }
		if (HX_FIELD_EQ(inName,"intersection") ) { return hx::Val( intersection_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"containsPoint") ) { return hx::Val( containsPoint_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_bottomRight") ) { return hx::Val( get_bottomRight_dyn()); }
		if (HX_FIELD_EQ(inName,"set_bottomRight") ) { return hx::Val( set_bottomRight_dyn()); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__toFlashRectangle") ) { return hx::Val( _hx___toFlashRectangle_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Rectangle_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"top") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_top(inValue) ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_left(inValue) ); }
		if (HX_FIELD_EQ(inName,"size") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_size(inValue) ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"right") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_right(inValue) ); }
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bottom") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_bottom(inValue) ); }
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"topLeft") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_topLeft(inValue) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"bottomRight") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_bottomRight(inValue) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Rectangle_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("bottom","\xeb","\xe6","\x78","\x65"));
	outFields->push(HX_HCSTRING("bottomRight","\xf1","\xa0","\xf4","\x4e"));
	outFields->push(HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"));
	outFields->push(HX_HCSTRING("left","\x07","\x08","\xb0","\x47"));
	outFields->push(HX_HCSTRING("right","\xdc","\x0b","\x64","\xe9"));
	outFields->push(HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c"));
	outFields->push(HX_HCSTRING("top","\x95","\x66","\x58","\x00"));
	outFields->push(HX_HCSTRING("topLeft","\x3c","\x09","\xc1","\xe8"));
	outFields->push(HX_HCSTRING("width","\x06","\xb6","\x62","\xca"));
	outFields->push(HX_HCSTRING("x","\x78","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("y","\x79","\x00","\x00","\x00"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Rectangle_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Rectangle_obj,height),HX_HCSTRING("height","\xe7","\x07","\x4c","\x02")},
	{hx::fsFloat,(int)offsetof(Rectangle_obj,width),HX_HCSTRING("width","\x06","\xb6","\x62","\xca")},
	{hx::fsFloat,(int)offsetof(Rectangle_obj,x),HX_HCSTRING("x","\x78","\x00","\x00","\x00")},
	{hx::fsFloat,(int)offsetof(Rectangle_obj,y),HX_HCSTRING("y","\x79","\x00","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Rectangle_obj_sStaticStorageInfo = 0;
#endif

static ::String Rectangle_obj_sMemberFields[] = {
	HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"),
	HX_HCSTRING("width","\x06","\xb6","\x62","\xca"),
	HX_HCSTRING("x","\x78","\x00","\x00","\x00"),
	HX_HCSTRING("y","\x79","\x00","\x00","\x00"),
	HX_HCSTRING("clone","\x5d","\x13","\x63","\x48"),
	HX_HCSTRING("contains","\x1f","\x5a","\x7b","\x2c"),
	HX_HCSTRING("containsPoint","\xb1","\xb9","\xeb","\x92"),
	HX_HCSTRING("containsRect","\xe3","\xce","\x1c","\xa6"),
	HX_HCSTRING("copyFrom","\xbf","\x0b","\x61","\xc8"),
	HX_HCSTRING("equals","\x3f","\xee","\xf2","\xbf"),
	HX_HCSTRING("inflate","\x87","\x9c","\x1b","\x0c"),
	HX_HCSTRING("inflatePoint","\x49","\xbe","\x39","\x32"),
	HX_HCSTRING("intersection","\x49","\xa2","\x61","\x88"),
	HX_HCSTRING("intersects","\xb4","\xc2","\xeb","\xe3"),
	HX_HCSTRING("isEmpty","\x43","\xde","\x5f","\x0c"),
	HX_HCSTRING("offset","\x93","\x97","\x3f","\x60"),
	HX_HCSTRING("offsetPoint","\xbd","\x37","\x10","\x5f"),
	HX_HCSTRING("setEmpty","\x8b","\xa3","\x0e","\x7e"),
	HX_HCSTRING("setTo","\xbd","\x91","\x2f","\x7a"),
	HX_HCSTRING("transform","\x6c","\x2d","\x93","\x45"),
	HX_HCSTRING("union","\x0f","\x65","\xe7","\xa6"),
	HX_HCSTRING("__contract","\x32","\x52","\xea","\xda"),
	HX_HCSTRING("__expand","\x7a","\x59","\xa2","\x6c"),
	HX_HCSTRING("__toFlashRectangle","\x5a","\x56","\x1a","\x96"),
	HX_HCSTRING("get_bottom","\xb4","\x56","\x00","\x56"),
	HX_HCSTRING("set_bottom","\x28","\xf5","\x7d","\x59"),
	HX_HCSTRING("get_bottomRight","\x88","\x58","\xd6","\x0f"),
	HX_HCSTRING("set_bottomRight","\x94","\xd5","\xa1","\x0b"),
	HX_HCSTRING("get_left","\x90","\xc3","\x6a","\xc7"),
	HX_HCSTRING("set_left","\x04","\x1d","\xc8","\x75"),
	HX_HCSTRING("get_right","\x33","\x68","\x0d","\x2d"),
	HX_HCSTRING("set_right","\x3f","\x54","\x5e","\x10"),
	HX_HCSTRING("get_size","\x4a","\x5c","\x0e","\xcc"),
	HX_HCSTRING("set_size","\xbe","\xb5","\x6b","\x7a"),
	HX_HCSTRING("get_top","\x2c","\x2f","\xcd","\x26"),
	HX_HCSTRING("set_top","\x38","\xc0","\xce","\x19"),
	HX_HCSTRING("get_topLeft","\x53","\x69","\xbb","\x6e"),
	HX_HCSTRING("set_topLeft","\x5f","\x70","\x28","\x79"),
	::String(null()) };

static void Rectangle_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Rectangle_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Rectangle_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Rectangle_obj::__mClass,"__mClass");
};

#endif

hx::Class Rectangle_obj::__mClass;

void Rectangle_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("lime.math.Rectangle","\x22","\x67","\x0f","\x89");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Rectangle_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Rectangle_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Rectangle_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Rectangle_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Rectangle_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Rectangle_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace math

// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix3D
#include <openfl/geom/Matrix3D.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_geom_Transform
#include <openfl/geom/Transform.h>
#endif

namespace openfl{
namespace geom{

void Transform_obj::__construct( ::openfl::display::DisplayObject displayObject){
            	HX_STACK_FRAME("openfl.geom.Transform","new",0x993cc92a,"openfl.geom.Transform.new","openfl/geom/Transform.hx",31,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(displayObject,"displayObject")
HXLINE(  33)		this->_hx___colorTransform =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  34)		this->concatenatedColorTransform =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  35)		this->pixelBounds =  ::openfl::geom::Rectangle_obj::__new(null(),null(),null(),null());
HXLINE(  37)		this->_hx___displayObject = displayObject;
HXLINE(  38)		this->_hx___hasMatrix = true;
            	}

Dynamic Transform_obj::__CreateEmpty() { return new Transform_obj; }

hx::ObjectPtr< Transform_obj > Transform_obj::__new( ::openfl::display::DisplayObject displayObject)
{
	hx::ObjectPtr< Transform_obj > _hx_result = new Transform_obj();
	_hx_result->__construct(displayObject);
	return _hx_result;
}

Dynamic Transform_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Transform_obj > _hx_result = new Transform_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

 ::openfl::geom::ColorTransform Transform_obj::get_colorTransform(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_colorTransform",0xc8c832c8,"openfl.geom.Transform.get_colorTransform","openfl/geom/Transform.hx",52,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  52)		return this->_hx___colorTransform;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_colorTransform,return )

 ::openfl::geom::ColorTransform Transform_obj::set_colorTransform( ::openfl::geom::ColorTransform value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_colorTransform",0xa577653c,"openfl.geom.Transform.set_colorTransform","openfl/geom/Transform.hx",57,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(  59)		Bool _hx_tmp = !(this->_hx___colorTransform->_hx___equals(value,null()));
HXDLIN(  59)		if (_hx_tmp) {
HXLINE(  61)			this->_hx___colorTransform = value;
HXLINE(  63)			Bool _hx_tmp1 = hx::IsNotNull( value );
HXDLIN(  63)			if (_hx_tmp1) {
HXLINE(  65)				this->_hx___displayObject->set_alpha(value->alphaMultiplier);
            			}
HXLINE(  69)			{
HXLINE(  69)				HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___displayObject;
HXDLIN(  69)				Bool _hx_tmp2 = !(_this->_hx___renderDirty);
HXDLIN(  69)				if (_hx_tmp2) {
HXLINE(  69)					_this->_hx___renderDirty = true;
HXDLIN(  69)					::openfl::display::DisplayObject_obj::_hx___worldRenderDirty++;
            				}
            			}
            		}
HXLINE(  73)		return this->_hx___colorTransform;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_colorTransform,return )

 ::openfl::geom::Matrix Transform_obj::get_concatenatedMatrix(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_concatenatedMatrix",0x352d276f,"openfl.geom.Transform.get_concatenatedMatrix","openfl/geom/Transform.hx",78,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  80)		Bool _hx_tmp = this->_hx___hasMatrix;
HXDLIN(  80)		if (_hx_tmp) {
HXLINE(  82)			return this->_hx___displayObject->_hx___getWorldTransform()->clone();
            		}
HXLINE(  86)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_concatenatedMatrix,return )

 ::openfl::geom::Matrix Transform_obj::get_matrix(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_matrix",0x80c3ba80,"openfl.geom.Transform.get_matrix","openfl/geom/Transform.hx",91,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE(  93)		Bool _hx_tmp = this->_hx___hasMatrix;
HXDLIN(  93)		if (_hx_tmp) {
HXLINE(  95)			return this->_hx___displayObject->_hx___transform->clone();
            		}
HXLINE(  99)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_matrix,return )

 ::openfl::geom::Matrix Transform_obj::set_matrix( ::openfl::geom::Matrix value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_matrix",0x844158f4,"openfl.geom.Transform.set_matrix","openfl/geom/Transform.hx",104,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 106)		Bool _hx_tmp = hx::IsNull( value );
HXDLIN( 106)		if (_hx_tmp) {
HXLINE( 108)			this->_hx___hasMatrix = false;
HXLINE( 109)			return null();
            		}
HXLINE( 113)		this->_hx___hasMatrix = true;
HXLINE( 114)		this->_hx___hasMatrix3D = false;
HXLINE( 116)		Bool _hx_tmp1 = hx::IsNotNull( this->_hx___displayObject );
HXDLIN( 116)		if (_hx_tmp1) {
HXLINE( 118)			this->_hx___setTransform(value->a,value->b,value->c,value->d,value->tx,value->ty);
            		}
HXLINE( 122)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_matrix,return )

 ::openfl::geom::Matrix3D Transform_obj::get_matrix3D(){
            	HX_STACK_FRAME("openfl.geom.Transform","get_matrix3D",0x05078731,"openfl.geom.Transform.get_matrix3D","openfl/geom/Transform.hx",127,0xf4f475e6)
            	HX_STACK_THIS(this)
HXLINE( 129)		Bool _hx_tmp = this->_hx___hasMatrix3D;
HXDLIN( 129)		if (_hx_tmp) {
HXLINE( 131)			HX_VARI(  ::openfl::geom::Matrix,matrix) = this->_hx___displayObject->_hx___transform;
HXLINE( 132)			HX_VARI( ::Array< Float >,a) = ::Array_obj< Float >::__new(16)->init(0,matrix->a)->init(1,matrix->b)->init(2,((Float)0.0))->init(3,((Float)0.0))->init(4,matrix->c)->init(5,matrix->d)->init(6,((Float)0.0))->init(7,((Float)0.0))->init(8,((Float)0.0))->init(9,((Float)0.0))->init(10,((Float)1.0))->init(11,((Float)0.0))->init(12,matrix->tx)->init(13,matrix->ty)->init(14,((Float)0.0))->init(15,((Float)1.0));
HXDLIN( 132)			Int length = null();
HXDLIN( 132)			Bool fixed = null();
HXDLIN( 132)			HX_VARI(  ::openfl::_Vector::FloatVector,vector) =  ::openfl::_Vector::FloatVector_obj::__new(length,fixed,null());
HXDLIN( 132)			{
HXLINE( 132)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 132)				HX_VARI( Int,_g) = a->length;
HXDLIN( 132)				while((_g1 < _g)){
HXLINE( 132)					HX_VARI( Int,i) = _g1++;
HXDLIN( 132)					vector->set(i,a->__get(i));
            				}
            			}
HXDLIN( 132)			return  ::openfl::geom::Matrix3D_obj::__new(vector);
            		}
HXLINE( 136)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,get_matrix3D,return )

 ::openfl::geom::Matrix3D Transform_obj::set_matrix3D( ::openfl::geom::Matrix3D value){
            	HX_STACK_FRAME("openfl.geom.Transform","set_matrix3D",0x1a00aaa5,"openfl.geom.Transform.set_matrix3D","openfl/geom/Transform.hx",141,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 143)		Bool _hx_tmp = hx::IsNull( value );
HXDLIN( 143)		if (_hx_tmp) {
HXLINE( 145)			this->_hx___hasMatrix3D = false;
HXLINE( 146)			return null();
            		}
HXLINE( 150)		this->_hx___hasMatrix = false;
HXLINE( 151)		this->_hx___hasMatrix3D = true;
HXLINE( 153)		this->_hx___setTransform(value->rawData->get((int)0),value->rawData->get((int)1),value->rawData->get((int)5),value->rawData->get((int)6),value->rawData->get((int)12),value->rawData->get((int)13));
HXLINE( 155)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,set_matrix3D,return )

void Transform_obj::_hx___setTransform(Float a,Float b,Float c,Float d,Float tx,Float ty){
            	HX_STACK_FRAME("openfl.geom.Transform","__setTransform",0x9df9f800,"openfl.geom.Transform.__setTransform","openfl/geom/Transform.hx",162,0xf4f475e6)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(c,"c")
            	HX_STACK_ARG(d,"d")
            	HX_STACK_ARG(tx,"tx")
            	HX_STACK_ARG(ty,"ty")
HXLINE( 162)		Bool _hx_tmp = hx::IsNotNull( this->_hx___displayObject );
HXDLIN( 162)		if (_hx_tmp) {
HXLINE( 164)			HX_VARI( Float,scaleX) = ((Float)0.0);
HXLINE( 165)			HX_VARI( Float,scaleY) = ((Float)0.0);
HXLINE( 167)			if ((b == (int)0)) {
HXLINE( 169)				scaleX = a;
            			}
            			else {
HXLINE( 173)				scaleX = ::Math_obj::sqrt(((a * a) + (b * b)));
            			}
HXLINE( 177)			if ((c == (int)0)) {
HXLINE( 179)				scaleY = a;
            			}
            			else {
HXLINE( 183)				scaleY = ::Math_obj::sqrt(((c * c) + (d * d)));
            			}
HXLINE( 187)			this->_hx___displayObject->_hx___scaleX = scaleX;
HXLINE( 188)			this->_hx___displayObject->_hx___scaleY = scaleY;
HXLINE( 190)			Float _hx_tmp1 = ((Float)(int)180 / (Float)::Math_obj::PI);
HXDLIN( 190)			Float _hx_tmp2 = ::Math_obj::atan2(d,c);
HXDLIN( 190)			HX_VARI( Float,rotation) = ((_hx_tmp1 * _hx_tmp2) - (int)90);
HXLINE( 192)			Bool _hx_tmp3 = (rotation != this->_hx___displayObject->_hx___rotation);
HXDLIN( 192)			if (_hx_tmp3) {
HXLINE( 194)				this->_hx___displayObject->_hx___rotation = rotation;
HXLINE( 195)				HX_VARI( Float,radians) = (rotation * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 196)				this->_hx___displayObject->_hx___rotationSine = ::Math_obj::sin(radians);
HXLINE( 197)				this->_hx___displayObject->_hx___rotationCosine = ::Math_obj::cos(radians);
            			}
HXLINE( 201)			this->_hx___displayObject->_hx___transform->a = a;
HXLINE( 202)			this->_hx___displayObject->_hx___transform->b = b;
HXLINE( 203)			this->_hx___displayObject->_hx___transform->c = c;
HXLINE( 204)			this->_hx___displayObject->_hx___transform->d = d;
HXLINE( 205)			this->_hx___displayObject->_hx___transform->tx = tx;
HXLINE( 206)			this->_hx___displayObject->_hx___transform->ty = ty;
HXLINE( 208)			{
HXLINE( 208)				HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___displayObject;
HXDLIN( 208)				Bool _hx_tmp4 = !(_this->_hx___transformDirty);
HXDLIN( 208)				if (_hx_tmp4) {
HXLINE( 208)					_this->_hx___transformDirty = true;
HXDLIN( 208)					::openfl::display::DisplayObject_obj::_hx___worldTransformDirty++;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(Transform_obj,_hx___setTransform,(void))


Transform_obj::Transform_obj()
{
}

void Transform_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Transform);
	HX_MARK_MEMBER_NAME(concatenatedColorTransform,"concatenatedColorTransform");
	HX_MARK_MEMBER_NAME(pixelBounds,"pixelBounds");
	HX_MARK_MEMBER_NAME(_hx___colorTransform,"__colorTransform");
	HX_MARK_MEMBER_NAME(_hx___displayObject,"__displayObject");
	HX_MARK_MEMBER_NAME(_hx___hasMatrix,"__hasMatrix");
	HX_MARK_MEMBER_NAME(_hx___hasMatrix3D,"__hasMatrix3D");
	HX_MARK_END_CLASS();
}

void Transform_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(concatenatedColorTransform,"concatenatedColorTransform");
	HX_VISIT_MEMBER_NAME(pixelBounds,"pixelBounds");
	HX_VISIT_MEMBER_NAME(_hx___colorTransform,"__colorTransform");
	HX_VISIT_MEMBER_NAME(_hx___displayObject,"__displayObject");
	HX_VISIT_MEMBER_NAME(_hx___hasMatrix,"__hasMatrix");
	HX_VISIT_MEMBER_NAME(_hx___hasMatrix3D,"__hasMatrix3D");
}

hx::Val Transform_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_matrix()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"matrix3D") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_matrix3D()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_matrix") ) { return hx::Val( get_matrix_dyn()); }
		if (HX_FIELD_EQ(inName,"set_matrix") ) { return hx::Val( set_matrix_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pixelBounds") ) { return hx::Val( pixelBounds); }
		if (HX_FIELD_EQ(inName,"__hasMatrix") ) { return hx::Val( _hx___hasMatrix); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_matrix3D") ) { return hx::Val( get_matrix3D_dyn()); }
		if (HX_FIELD_EQ(inName,"set_matrix3D") ) { return hx::Val( set_matrix3D_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__hasMatrix3D") ) { return hx::Val( _hx___hasMatrix3D); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_colorTransform()); }
		if (HX_FIELD_EQ(inName,"__setTransform") ) { return hx::Val( _hx___setTransform_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__displayObject") ) { return hx::Val( _hx___displayObject); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__colorTransform") ) { return hx::Val( _hx___colorTransform); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"concatenatedMatrix") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_concatenatedMatrix()); }
		if (HX_FIELD_EQ(inName,"get_colorTransform") ) { return hx::Val( get_colorTransform_dyn()); }
		if (HX_FIELD_EQ(inName,"set_colorTransform") ) { return hx::Val( set_colorTransform_dyn()); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"get_concatenatedMatrix") ) { return hx::Val( get_concatenatedMatrix_dyn()); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"concatenatedColorTransform") ) { return hx::Val( concatenatedColorTransform); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Transform_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_matrix(inValue) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"matrix3D") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_matrix3D(inValue) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pixelBounds") ) { pixelBounds=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__hasMatrix") ) { _hx___hasMatrix=inValue.Cast< Bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__hasMatrix3D") ) { _hx___hasMatrix3D=inValue.Cast< Bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_colorTransform(inValue) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__displayObject") ) { _hx___displayObject=inValue.Cast<  ::openfl::display::DisplayObject >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__colorTransform") ) { _hx___colorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"concatenatedColorTransform") ) { concatenatedColorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Transform_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"));
	outFields->push(HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77"));
	outFields->push(HX_HCSTRING("concatenatedMatrix","\xb0","\xc0","\x9c","\xf8"));
	outFields->push(HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"));
	outFields->push(HX_HCSTRING("matrix3D","\x32","\x35","\xf3","\x66"));
	outFields->push(HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7"));
	outFields->push(HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1"));
	outFields->push(HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e"));
	outFields->push(HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a"));
	outFields->push(HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Transform_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(int)offsetof(Transform_obj,concatenatedColorTransform),HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(Transform_obj,pixelBounds),HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7")},
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(int)offsetof(Transform_obj,_hx___colorTransform),HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1")},
	{hx::fsObject /*::openfl::display::DisplayObject*/ ,(int)offsetof(Transform_obj,_hx___displayObject),HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e")},
	{hx::fsBool,(int)offsetof(Transform_obj,_hx___hasMatrix),HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a")},
	{hx::fsBool,(int)offsetof(Transform_obj,_hx___hasMatrix3D),HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Transform_obj_sStaticStorageInfo = 0;
#endif

static ::String Transform_obj_sMemberFields[] = {
	HX_HCSTRING("concatenatedColorTransform","\xf8","\xe8","\x5a","\x77"),
	HX_HCSTRING("pixelBounds","\x9b","\x69","\xaa","\xd7"),
	HX_HCSTRING("__colorTransform","\xa9","\x62","\x7f","\xe1"),
	HX_HCSTRING("__displayObject","\x81","\x73","\x54","\x5e"),
	HX_HCSTRING("__hasMatrix","\x1b","\x32","\xdd","\x2a"),
	HX_HCSTRING("__hasMatrix3D","\x8c","\x5b","\x22","\x82"),
	HX_HCSTRING("get_colorTransform","\x52","\xb8","\xd9","\x48"),
	HX_HCSTRING("set_colorTransform","\xc6","\xea","\x88","\x25"),
	HX_HCSTRING("get_concatenatedMatrix","\xf9","\x39","\x31","\x52"),
	HX_HCSTRING("get_matrix","\x0a","\xa6","\x4f","\xac"),
	HX_HCSTRING("set_matrix","\x7e","\x44","\xcd","\xaf"),
	HX_HCSTRING("get_matrix3D","\x3b","\xe9","\x0c","\x1c"),
	HX_HCSTRING("set_matrix3D","\xaf","\x0c","\x06","\x31"),
	HX_HCSTRING("__setTransform","\x8a","\x70","\xa3","\x8a"),
	::String(null()) };

static void Transform_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Transform_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Transform_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Transform_obj::__mClass,"__mClass");
};

#endif

hx::Class Transform_obj::__mClass;

void Transform_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.geom.Transform","\x38","\xac","\x4a","\xe3");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Transform_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Transform_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Transform_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Transform_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Transform_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Transform_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace geom

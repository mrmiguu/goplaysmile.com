// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__backend_native_NativeGLRenderContext
#include <lime/_backend/native/NativeGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLBuffer
#include <lime/graphics/opengl/GLBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractBlendModeManager
#include <openfl/_internal/renderer/AbstractBlendModeManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractFilterManager
#include <openfl/_internal/renderer/AbstractFilterManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractMaskManager
#include <openfl/_internal/renderer/AbstractMaskManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractRenderer
#include <openfl/_internal/renderer/AbstractRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractShaderManager
#include <openfl/_internal/renderer/AbstractShaderManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLRenderer
#include <openfl/_internal/renderer/opengl/GLRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLTilemap
#include <openfl/_internal/renderer/opengl/GLTilemap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderData
#include <openfl/display/ShaderData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_Tile
#include <openfl/display/Tile.h>
#endif
#ifndef INCLUDED_openfl_display_Tilemap
#include <openfl/display/Tilemap.h>
#endif
#ifndef INCLUDED_openfl_display_Tileset
#include <openfl/display/Tileset.h>
#endif
#ifndef INCLUDED_openfl_display__Tileset_TileData
#include <openfl/display/_Tileset/TileData.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_32_render,"openfl._internal.renderer.opengl.GLTilemap","render",0xde22397f,"openfl._internal.renderer.opengl.GLTilemap.render","openfl/_internal/renderer/opengl/GLTilemap.hx",32,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_284___skipTile,"openfl._internal.renderer.opengl.GLTilemap","__skipTile",0x426fc316,"openfl._internal.renderer.opengl.GLTilemap.__skipTile","openfl/_internal/renderer/opengl/GLTilemap.hx",284,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_301___updateTileAlpha,"openfl._internal.renderer.opengl.GLTilemap","__updateTileAlpha",0x6bbd875e,"openfl._internal.renderer.opengl.GLTilemap.__updateTileAlpha","openfl/_internal/renderer/opengl/GLTilemap.hx",301,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_317___updateTileUV,"openfl._internal.renderer.opengl.GLTilemap","__updateTileUV",0xdacd8641,"openfl._internal.renderer.opengl.GLTilemap.__updateTileUV","openfl/_internal/renderer/opengl/GLTilemap.hx",317,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_29_boot,"openfl._internal.renderer.opengl.GLTilemap","boot",0xf7b1461b,"openfl._internal.renderer.opengl.GLTilemap.boot","openfl/_internal/renderer/opengl/GLTilemap.hx",29,0xf59b2d1b)
namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{

void GLTilemap_obj::__construct() { }

Dynamic GLTilemap_obj::__CreateEmpty() { return new GLTilemap_obj; }

void *GLTilemap_obj::_hx_vtable = 0;

Dynamic GLTilemap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLTilemap_obj > _hx_result = new GLTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GLTilemap_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x22e44b0b;
}

 ::haxe::ds::IntMap GLTilemap_obj::_hx___skippedTiles;

void GLTilemap_obj::render( ::openfl::display::Tilemap tilemap, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_GC_STACKFRAME(&_hx_pos_40a075b64d21c9aa_32_render)
HXLINE(  34)		bool _hx_tmp;
HXDLIN(  34)		bool _hx_tmp1;
HXDLIN(  34)		if (!(!(tilemap->_hx___renderable))) {
HXLINE(  34)			_hx_tmp1 = (tilemap->_hx___tiles->length == (int)0);
            		}
            		else {
HXLINE(  34)			_hx_tmp1 = true;
            		}
HXDLIN(  34)		if (!(_hx_tmp1)) {
HXLINE(  34)			_hx_tmp = (tilemap->_hx___worldAlpha <= (int)0);
            		}
            		else {
HXLINE(  34)			_hx_tmp = true;
            		}
HXDLIN(  34)		if (_hx_tmp) {
HXLINE(  34)			return;
            		}
HXLINE(  36)		 ::openfl::_internal::renderer::opengl::GLRenderer renderer = ( ( ::openfl::_internal::renderer::opengl::GLRenderer)(renderSession->renderer) );
HXLINE(  37)		 ::lime::_backend::native::NativeGLRenderContext gl = renderSession->gl;
HXLINE(  39)		 ::openfl::_internal::renderer::AbstractBlendModeManager renderSession1 = renderSession->blendModeManager;
HXDLIN(  39)		renderSession1->setBlendMode(tilemap->get_blendMode());
HXLINE(  40)		renderSession->maskManager->pushObject(tilemap,null());
HXLINE(  42)		 ::openfl::display::Shader shader = renderSession->filterManager->pushObject(tilemap);
HXLINE(  44)		 ::openfl::geom::Rectangle rect = ::openfl::geom::Rectangle_obj::_hx___temp;
HXLINE(  45)		rect->setTo((int)0,(int)0,tilemap->_hx___width,tilemap->_hx___height);
HXLINE(  46)		renderSession->maskManager->pushRect(rect,tilemap->_hx___renderTransform);
HXLINE(  48)		shader->get_data()->uMatrix->value = renderer->getMatrix(tilemap->_hx___renderTransform);
HXLINE(  49)		bool _hx_tmp2;
HXDLIN(  49)		if (renderSession->allowSmoothing) {
HXLINE(  49)			_hx_tmp2 = tilemap->smoothing;
            		}
            		else {
HXLINE(  49)			_hx_tmp2 = false;
            		}
HXDLIN(  49)		shader->get_data()->uImage0->smoothing = _hx_tmp2;
HXLINE(  51)		 ::openfl::display::Tileset defaultTileset = tilemap->tileset;
HXLINE(  52)		Float worldAlpha = tilemap->_hx___worldAlpha;
HXLINE(  53)		bool alphaDirty = (tilemap->_hx___worldAlpha != tilemap->_hx___cacheAlpha);
HXLINE(  55)		::Array< ::Dynamic> tiles;
HXDLIN(  55)		int count;
HXDLIN(  55)		 ::lime::utils::ArrayBufferView bufferData;
HXDLIN(  55)		 ::Dynamic buffer;
HXDLIN(  55)		int startIndex;
HXDLIN(  55)		int offset;
HXDLIN(  55)		 ::Dynamic uvs;
HXDLIN(  55)		 ::Dynamic uv;
HXLINE(  56)		int tileWidth = (int)0;
HXDLIN(  56)		int tileHeight = (int)0;
HXLINE(  57)		 ::openfl::display::Tile tile;
HXDLIN(  57)		Float alpha;
HXDLIN(  57)		bool visible;
HXDLIN(  57)		 ::openfl::display::Tileset tileset;
HXDLIN(  57)		 ::openfl::display::_Tileset::TileData tileData;
HXDLIN(  57)		 ::openfl::geom::Matrix tileMatrix;
HXDLIN(  57)		Float x;
HXDLIN(  57)		Float y;
HXDLIN(  57)		Float x2;
HXDLIN(  57)		Float y2;
HXDLIN(  57)		Float x3;
HXDLIN(  57)		Float y3;
HXDLIN(  57)		Float x4;
HXDLIN(  57)		Float y4;
HXLINE(  59)		tiles = tilemap->_hx___tiles;
HXLINE(  60)		count = tiles->length;
HXLINE(  62)		bufferData = tilemap->_hx___bufferData;
HXLINE(  64)		bool _hx_tmp3;
HXDLIN(  64)		bool _hx_tmp4;
HXDLIN(  64)		if (hx::IsNotNull( bufferData )) {
HXLINE(  64)			_hx_tmp4 = tilemap->_hx___dirty;
            		}
            		else {
HXLINE(  64)			_hx_tmp4 = true;
            		}
HXDLIN(  64)		if (!(_hx_tmp4)) {
HXLINE(  64)			int bufferData1 = bufferData->length;
HXDLIN(  64)			_hx_tmp3 = (bufferData1 != (count * (int)30));
            		}
            		else {
HXLINE(  64)			_hx_tmp3 = true;
            		}
HXDLIN(  64)		if (_hx_tmp3) {
HXLINE(  66)			startIndex = (int)0;
HXLINE(  68)			if (hx::IsNull( bufferData )) {
HXLINE(  70)				 ::Dynamic elements = (count * (int)30);
HXDLIN(  70)				 ::lime::utils::ArrayBufferView this1;
HXDLIN(  70)				if (hx::IsNotNull( elements )) {
HXLINE(  70)					this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements,(int)8);
            				}
            				else {
HXLINE(  70)					HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            				}
HXDLIN(  70)				bufferData = this1;
            			}
            			else {
HXLINE(  72)				int bufferData2 = bufferData->length;
HXDLIN(  72)				if ((bufferData2 != (count * (int)30))) {
HXLINE(  74)					if (!(tilemap->_hx___dirty)) {
HXLINE(  76)						startIndex = ::Std_obj::_hx_int(((Float)bufferData->length / (Float)(int)30));
            					}
HXLINE(  80)					 ::Dynamic elements1 = (count * (int)30);
HXDLIN(  80)					 ::lime::utils::ArrayBufferView this2;
HXDLIN(  80)					if (hx::IsNotNull( elements1 )) {
HXLINE(  80)						this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,elements1,(int)8);
            					}
            					else {
HXLINE(  80)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
HXDLIN(  80)					 ::lime::utils::ArrayBufferView data = this2;
HXLINE(  82)					if ((bufferData->length <= data->length)) {
HXLINE(  84)						int offset1 = (int)0;
HXDLIN(  84)						if (hx::IsNotNull( bufferData )) {
HXLINE(  84)							 ::haxe::io::Bytes data1 = data->buffer;
HXDLIN(  84)							data1->blit((offset1 * data->bytesPerElement),bufferData->buffer,bufferData->byteOffset,bufferData->byteLength);
            						}
            						else {
HXLINE(  84)							HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            						}
            					}
            					else {
HXLINE(  88)						 ::Dynamic end = data->length;
HXDLIN(  88)						bool _hx_tmp5 = hx::IsNull( end );
HXDLIN(  88)						int len = end;
HXDLIN(  88)						int byte_offset = (((int)0 * bufferData->bytesPerElement) + bufferData->byteOffset);
HXDLIN(  88)						 ::lime::utils::ArrayBufferView view;
HXDLIN(  88)						int _g = bufferData->type;
HXDLIN(  88)						switch((int)(_g)){
            							case (int)0: {
HXLINE(  88)								HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            							}
            							break;
            							case (int)1: {
HXLINE(  88)								 ::haxe::io::Bytes buffer1 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this3;
HXDLIN(  88)								if (hx::IsNotNull( buffer1 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)1);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength = buffer1->length;
HXDLIN(  88)									int elementSize = _this->bytesPerElement;
HXDLIN(  88)									int newByteLength = bufferByteLength;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength = (bufferByteLength - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength,_this->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength = (len * _this->bytesPerElement);
HXDLIN(  88)										int newRange = (byte_offset + newByteLength);
HXDLIN(  88)										if ((newRange > bufferByteLength)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this->buffer = buffer1;
HXDLIN(  88)									_this->byteOffset = byte_offset;
HXDLIN(  88)									_this->byteLength = newByteLength;
HXDLIN(  88)									_this->length = ::Std_obj::_hx_int(((Float)newByteLength / (Float)_this->bytesPerElement));
HXDLIN(  88)									this3 = _this;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int8Array",40,53,da,77));
            								}
HXDLIN(  88)								view = this3;
            							}
            							break;
            							case (int)2: {
HXLINE(  88)								 ::haxe::io::Bytes buffer2 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this4;
HXDLIN(  88)								if (hx::IsNotNull( buffer2 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)2);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this1->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength1 = buffer2->length;
HXDLIN(  88)									int elementSize1 = _this1->bytesPerElement;
HXDLIN(  88)									int newByteLength1 = bufferByteLength1;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength1 = (bufferByteLength1 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength1,_this1->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength1 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength1 = (len * _this1->bytesPerElement);
HXDLIN(  88)										int newRange1 = (byte_offset + newByteLength1);
HXDLIN(  88)										if ((newRange1 > bufferByteLength1)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this1->buffer = buffer2;
HXDLIN(  88)									_this1->byteOffset = byte_offset;
HXDLIN(  88)									_this1->byteLength = newByteLength1;
HXDLIN(  88)									_this1->length = ::Std_obj::_hx_int(((Float)newByteLength1 / (Float)_this1->bytesPerElement));
HXDLIN(  88)									this4 = _this1;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int16Array",95,b2,95,a7));
            								}
HXDLIN(  88)								view = this4;
            							}
            							break;
            							case (int)3: {
HXLINE(  88)								 ::haxe::io::Bytes buffer3 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this5;
HXDLIN(  88)								if (hx::IsNotNull( buffer3 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)3);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this2->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength2 = buffer3->length;
HXDLIN(  88)									int elementSize2 = _this2->bytesPerElement;
HXDLIN(  88)									int newByteLength2 = bufferByteLength2;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength2 = (bufferByteLength2 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength2,_this2->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength2 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength2 = (len * _this2->bytesPerElement);
HXDLIN(  88)										int newRange2 = (byte_offset + newByteLength2);
HXDLIN(  88)										if ((newRange2 > bufferByteLength2)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this2->buffer = buffer3;
HXDLIN(  88)									_this2->byteOffset = byte_offset;
HXDLIN(  88)									_this2->byteLength = newByteLength2;
HXDLIN(  88)									_this2->length = ::Std_obj::_hx_int(((Float)newByteLength2 / (Float)_this2->bytesPerElement));
HXDLIN(  88)									this5 = _this2;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int32Array",9b,2e,53,61));
            								}
HXDLIN(  88)								view = this5;
            							}
            							break;
            							case (int)4: {
HXLINE(  88)								 ::haxe::io::Bytes buffer4 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this6;
HXDLIN(  88)								if (hx::IsNotNull( buffer4 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this3 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)4);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this3->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength3 = buffer4->length;
HXDLIN(  88)									int elementSize3 = _this3->bytesPerElement;
HXDLIN(  88)									int newByteLength3 = bufferByteLength3;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength3 = (bufferByteLength3 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength3,_this3->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength3 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength3 = (len * _this3->bytesPerElement);
HXDLIN(  88)										int newRange3 = (byte_offset + newByteLength3);
HXDLIN(  88)										if ((newRange3 > bufferByteLength3)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this3->buffer = buffer4;
HXDLIN(  88)									_this3->byteOffset = byte_offset;
HXDLIN(  88)									_this3->byteLength = newByteLength3;
HXDLIN(  88)									_this3->length = ::Std_obj::_hx_int(((Float)newByteLength3 / (Float)_this3->bytesPerElement));
HXDLIN(  88)									this6 = _this3;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8Array",6b,44,d5,85));
            								}
HXDLIN(  88)								view = this6;
            							}
            							break;
            							case (int)5: {
HXLINE(  88)								 ::haxe::io::Bytes buffer5 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this7;
HXDLIN(  88)								if (hx::IsNotNull( buffer5 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this4 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)5);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this4->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength4 = buffer5->length;
HXDLIN(  88)									int elementSize4 = _this4->bytesPerElement;
HXDLIN(  88)									int newByteLength4 = bufferByteLength4;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength4 = (bufferByteLength4 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength4,_this4->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength4 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength4 = (len * _this4->bytesPerElement);
HXDLIN(  88)										int newRange4 = (byte_offset + newByteLength4);
HXDLIN(  88)										if ((newRange4 > bufferByteLength4)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this4->buffer = buffer5;
HXDLIN(  88)									_this4->byteOffset = byte_offset;
HXDLIN(  88)									_this4->byteLength = newByteLength4;
HXDLIN(  88)									_this4->length = ::Std_obj::_hx_int(((Float)newByteLength4 / (Float)_this4->bytesPerElement));
HXDLIN(  88)									this7 = _this4;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt8ClampedArray",8d,06,77,13));
            								}
HXDLIN(  88)								view = this7;
            							}
            							break;
            							case (int)6: {
HXLINE(  88)								 ::haxe::io::Bytes buffer6 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this8;
HXDLIN(  88)								if (hx::IsNotNull( buffer6 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this5 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)6);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this5->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength5 = buffer6->length;
HXDLIN(  88)									int elementSize5 = _this5->bytesPerElement;
HXDLIN(  88)									int newByteLength5 = bufferByteLength5;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength5 = (bufferByteLength5 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength5,_this5->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength5 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength5 = (len * _this5->bytesPerElement);
HXDLIN(  88)										int newRange5 = (byte_offset + newByteLength5);
HXDLIN(  88)										if ((newRange5 > bufferByteLength5)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this5->buffer = buffer6;
HXDLIN(  88)									_this5->byteOffset = byte_offset;
HXDLIN(  88)									_this5->byteLength = newByteLength5;
HXDLIN(  88)									_this5->length = ::Std_obj::_hx_int(((Float)newByteLength5 / (Float)_this5->bytesPerElement));
HXDLIN(  88)									this8 = _this5;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt16Array",0a,c7,2d,d5));
            								}
HXDLIN(  88)								view = this8;
            							}
            							break;
            							case (int)7: {
HXLINE(  88)								 ::haxe::io::Bytes buffer7 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this9;
HXDLIN(  88)								if (hx::IsNotNull( buffer7 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this6 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)7);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this6->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength6 = buffer7->length;
HXDLIN(  88)									int elementSize6 = _this6->bytesPerElement;
HXDLIN(  88)									int newByteLength6 = bufferByteLength6;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength6 = (bufferByteLength6 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength6,_this6->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength6 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength6 = (len * _this6->bytesPerElement);
HXDLIN(  88)										int newRange6 = (byte_offset + newByteLength6);
HXDLIN(  88)										if ((newRange6 > bufferByteLength6)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this6->buffer = buffer7;
HXDLIN(  88)									_this6->byteOffset = byte_offset;
HXDLIN(  88)									_this6->byteLength = newByteLength6;
HXDLIN(  88)									_this6->length = ::Std_obj::_hx_int(((Float)newByteLength6 / (Float)_this6->bytesPerElement));
HXDLIN(  88)									this9 = _this6;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for UInt32Array",10,43,eb,8e));
            								}
HXDLIN(  88)								view = this9;
            							}
            							break;
            							case (int)8: {
HXLINE(  88)								 ::haxe::io::Bytes buffer8 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this10;
HXDLIN(  88)								if (hx::IsNotNull( buffer8 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this7 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)8);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this7->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength7 = buffer8->length;
HXDLIN(  88)									int elementSize7 = _this7->bytesPerElement;
HXDLIN(  88)									int newByteLength7 = bufferByteLength7;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength7 = (bufferByteLength7 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength7,_this7->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength7 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength7 = (len * _this7->bytesPerElement);
HXDLIN(  88)										int newRange7 = (byte_offset + newByteLength7);
HXDLIN(  88)										if ((newRange7 > bufferByteLength7)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this7->buffer = buffer8;
HXDLIN(  88)									_this7->byteOffset = byte_offset;
HXDLIN(  88)									_this7->byteLength = newByteLength7;
HXDLIN(  88)									_this7->length = ::Std_obj::_hx_int(((Float)newByteLength7 / (Float)_this7->bytesPerElement));
HXDLIN(  88)									this10 = _this7;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            								}
HXDLIN(  88)								view = this10;
            							}
            							break;
            							case (int)9: {
HXLINE(  88)								 ::haxe::io::Bytes buffer9 = bufferData->buffer;
HXDLIN(  88)								 ::lime::utils::ArrayBufferView this11;
HXDLIN(  88)								if (hx::IsNotNull( buffer9 )) {
HXLINE(  88)									 ::lime::utils::ArrayBufferView _this8 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,(int)0,(int)9);
HXDLIN(  88)									if ((byte_offset < (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									if ((hx::Mod(byte_offset,_this8->bytesPerElement) != (int)0)) {
HXLINE(  88)										HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            									}
HXDLIN(  88)									int bufferByteLength8 = buffer9->length;
HXDLIN(  88)									int elementSize8 = _this8->bytesPerElement;
HXDLIN(  88)									int newByteLength8 = bufferByteLength8;
HXDLIN(  88)									if (hx::IsNull( len )) {
HXLINE(  88)										newByteLength8 = (bufferByteLength8 - byte_offset);
HXDLIN(  88)										if ((hx::Mod(bufferByteLength8,_this8->bytesPerElement) != (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
HXDLIN(  88)										if ((newByteLength8 < (int)0)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
            									else {
HXLINE(  88)										newByteLength8 = (len * _this8->bytesPerElement);
HXDLIN(  88)										int newRange8 = (byte_offset + newByteLength8);
HXDLIN(  88)										if ((newRange8 > bufferByteLength8)) {
HXLINE(  88)											HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            										}
            									}
HXDLIN(  88)									_this8->buffer = buffer9;
HXDLIN(  88)									_this8->byteOffset = byte_offset;
HXDLIN(  88)									_this8->byteLength = newByteLength8;
HXDLIN(  88)									_this8->length = ::Std_obj::_hx_int(((Float)newByteLength8 / (Float)_this8->bytesPerElement));
HXDLIN(  88)									this11 = _this8;
            								}
            								else {
HXLINE(  88)									HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float64Array",8f,de,6b,1e));
            								}
HXDLIN(  88)								view = this11;
            							}
            							break;
            						}
HXDLIN(  88)						 ::lime::utils::ArrayBufferView view1 = view;
HXDLIN(  88)						int offset2 = (int)0;
HXDLIN(  88)						if (hx::IsNotNull( view1 )) {
HXLINE(  88)							 ::haxe::io::Bytes data2 = data->buffer;
HXDLIN(  88)							data2->blit((offset2 * data->bytesPerElement),view1->buffer,view1->byteOffset,view1->byteLength);
            						}
            						else {
HXLINE(  88)							HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            						}
            					}
HXLINE(  92)					bufferData = data;
            				}
            			}
HXLINE(  96)			{
HXLINE(  96)				int _g1 = startIndex;
HXDLIN(  96)				int _g2 = count;
HXDLIN(  96)				while((_g1 < _g2)){
HXLINE(  96)					_g1 = (_g1 + (int)1);
HXDLIN(  96)					int i = (_g1 - (int)1);
HXLINE(  98)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileAlpha(tiles->__get(i).StaticCast<  ::openfl::display::Tile >(),worldAlpha,(i * (int)30),bufferData);
HXLINE( 100)					if (hx::IsNotNull( tiles->__get(i).StaticCast<  ::openfl::display::Tile >()->tileset )) {
HXLINE( 100)						tileset = tiles->__get(i).StaticCast<  ::openfl::display::Tile >()->tileset;
            					}
            					else {
HXLINE( 100)						tileset = tilemap->tileset;
            					}
HXLINE( 102)					if (hx::IsNotNull( tileset )) {
HXLINE( 104)						::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileUV(tiles->__get(i).StaticCast<  ::openfl::display::Tile >(),tileset,(i * (int)30),bufferData);
            					}
            				}
            			}
HXLINE( 110)			tilemap->_hx___bufferData = bufferData;
            		}
HXLINE( 114)		if (hx::IsNull( tilemap->_hx___buffer )) {
HXLINE( 116)			tilemap->_hx___buffer = gl->createBuffer();
            		}
HXLINE( 120)		gl->bindBuffer(gl->ARRAY_BUFFER,tilemap->_hx___buffer);
HXLINE( 122)		int drawCount = (int)0;
HXLINE( 124)		{
HXLINE( 124)			int _g11 = (int)0;
HXDLIN( 124)			int _g3 = count;
HXDLIN( 124)			while((_g11 < _g3)){
HXLINE( 124)				_g11 = (_g11 + (int)1);
HXDLIN( 124)				int i1 = (_g11 - (int)1);
HXLINE( 126)				offset = (i1 * (int)30);
HXLINE( 128)				tile = tiles->__get(i1).StaticCast<  ::openfl::display::Tile >();
HXLINE( 130)				alpha = tile->alpha;
HXLINE( 131)				visible = tile->visible;
HXLINE( 133)				bool _hx_tmp6;
HXDLIN( 133)				if (!(!(visible))) {
HXLINE( 133)					_hx_tmp6 = (alpha <= (int)0);
            				}
            				else {
HXLINE( 133)					_hx_tmp6 = true;
            				}
HXDLIN( 133)				if (_hx_tmp6) {
HXLINE( 135)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 136)					continue;
            				}
HXLINE( 140)				if (hx::IsNotNull( tile->tileset )) {
HXLINE( 140)					tileset = tile->tileset;
            				}
            				else {
HXLINE( 140)					tileset = defaultTileset;
            				}
HXLINE( 142)				if (hx::IsNull( tileset )) {
HXLINE( 144)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 145)					continue;
            				}
HXLINE( 149)				tileData = tileset->_hx___data->__get(tile->id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 151)				if (hx::IsNull( tileData )) {
HXLINE( 153)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skipTile(tile,i1,offset,bufferData);
HXLINE( 154)					continue;
            				}
HXLINE( 158)				tileWidth = tileData->width;
HXLINE( 159)				tileHeight = tileData->height;
HXLINE( 163)				bool _hx_tmp7;
HXDLIN( 163)				if (!(alphaDirty)) {
HXLINE( 163)					_hx_tmp7 = tile->_hx___alphaDirty;
            				}
            				else {
HXLINE( 163)					_hx_tmp7 = true;
            				}
HXDLIN( 163)				if (_hx_tmp7) {
HXLINE( 165)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileAlpha(tile,worldAlpha,offset,bufferData);
            				}
HXLINE( 169)				if (tile->_hx___sourceDirty) {
HXLINE( 171)					::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___updateTileUV(tile,tileset,offset,bufferData);
            				}
HXLINE( 175)				if (tile->_hx___transformDirty) {
HXLINE( 177)					tileMatrix = ::openfl::geom::Matrix_obj::_hx___temp;
HXLINE( 178)					tileMatrix->setTo((int)1,(int)0,(int)0,(int)1,-(tile->originX),-(tile->originY));
HXLINE( 179)					tileMatrix->concat(tile->matrix);
HXLINE( 181)					Float x1 = ((int)0 * tileMatrix->a);
HXDLIN( 181)					x = (tile->_hx___transform[(int)0] = ((x1 + ((int)0 * tileMatrix->c)) + tileMatrix->tx));
HXLINE( 182)					Float y1 = ((int)0 * tileMatrix->b);
HXDLIN( 182)					y = (tile->_hx___transform[(int)1] = ((y1 + ((int)0 * tileMatrix->d)) + tileMatrix->ty));
HXLINE( 183)					Float x21 = (tileWidth * tileMatrix->a);
HXDLIN( 183)					x2 = (tile->_hx___transform[(int)2] = ((x21 + ((int)0 * tileMatrix->c)) + tileMatrix->tx));
HXLINE( 184)					Float y21 = (tileWidth * tileMatrix->b);
HXDLIN( 184)					y2 = (tile->_hx___transform[(int)3] = ((y21 + ((int)0 * tileMatrix->d)) + tileMatrix->ty));
HXLINE( 185)					Float x31 = ((int)0 * tileMatrix->a);
HXDLIN( 185)					x3 = (tile->_hx___transform[(int)4] = ((x31 + (tileHeight * tileMatrix->c)) + tileMatrix->tx));
HXLINE( 186)					Float y31 = ((int)0 * tileMatrix->b);
HXDLIN( 186)					y3 = (tile->_hx___transform[(int)5] = ((y31 + (tileHeight * tileMatrix->d)) + tileMatrix->ty));
HXLINE( 187)					Float x41 = (tileWidth * tileMatrix->a);
HXDLIN( 187)					x4 = (tile->_hx___transform[(int)6] = ((x41 + (tileHeight * tileMatrix->c)) + tileMatrix->tx));
HXLINE( 188)					Float y41 = (tileWidth * tileMatrix->b);
HXDLIN( 188)					y4 = (tile->_hx___transform[(int)7] = ((y41 + (tileHeight * tileMatrix->d)) + tileMatrix->ty));
HXLINE( 190)					tile->_hx___transformDirty = false;
            				}
            				else {
HXLINE( 194)					x = tile->_hx___transform->__get((int)0);
HXLINE( 195)					y = tile->_hx___transform->__get((int)1);
HXLINE( 196)					x2 = tile->_hx___transform->__get((int)2);
HXLINE( 197)					y2 = tile->_hx___transform->__get((int)3);
HXLINE( 198)					x3 = tile->_hx___transform->__get((int)4);
HXLINE( 199)					y3 = tile->_hx___transform->__get((int)5);
HXLINE( 200)					x4 = tile->_hx___transform->__get((int)6);
HXLINE( 201)					y4 = tile->_hx___transform->__get((int)7);
            				}
HXLINE( 205)				{
HXLINE( 205)					int bufferData3 = bufferData->byteOffset;
HXDLIN( 205)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData3 + (offset * (int)4)),x);
            				}
HXLINE( 206)				{
HXLINE( 206)					int bufferData4 = bufferData->byteOffset;
HXDLIN( 206)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData4 + ((offset + (int)1) * (int)4)),y);
            				}
HXLINE( 207)				{
HXLINE( 207)					int bufferData5 = bufferData->byteOffset;
HXDLIN( 207)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData5 + ((offset + (int)5) * (int)4)),x2);
            				}
HXLINE( 208)				{
HXLINE( 208)					int bufferData6 = bufferData->byteOffset;
HXDLIN( 208)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData6 + ((offset + (int)6) * (int)4)),y2);
            				}
HXLINE( 209)				{
HXLINE( 209)					int bufferData7 = bufferData->byteOffset;
HXDLIN( 209)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData7 + ((offset + (int)10) * (int)4)),x3);
            				}
HXLINE( 210)				{
HXLINE( 210)					int bufferData8 = bufferData->byteOffset;
HXDLIN( 210)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData8 + ((offset + (int)11) * (int)4)),y3);
            				}
HXLINE( 212)				{
HXLINE( 212)					int bufferData9 = bufferData->byteOffset;
HXDLIN( 212)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData9 + ((offset + (int)15) * (int)4)),x3);
            				}
HXLINE( 213)				{
HXLINE( 213)					int bufferData10 = bufferData->byteOffset;
HXDLIN( 213)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData10 + ((offset + (int)16) * (int)4)),y3);
            				}
HXLINE( 214)				{
HXLINE( 214)					int bufferData11 = bufferData->byteOffset;
HXDLIN( 214)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData11 + ((offset + (int)20) * (int)4)),x2);
            				}
HXLINE( 215)				{
HXLINE( 215)					int bufferData12 = bufferData->byteOffset;
HXDLIN( 215)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData12 + ((offset + (int)21) * (int)4)),y2);
            				}
HXLINE( 216)				{
HXLINE( 216)					int bufferData13 = bufferData->byteOffset;
HXDLIN( 216)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData13 + ((offset + (int)25) * (int)4)),x4);
            				}
HXLINE( 217)				{
HXLINE( 217)					int bufferData14 = bufferData->byteOffset;
HXDLIN( 217)					::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData14 + ((offset + (int)26) * (int)4)),y4);
            				}
HXLINE( 219)				drawCount = i1;
HXLINE( 221)				::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->set(i1,false);
            			}
            		}
HXLINE( 225)		gl->bufferData(gl->ARRAY_BUFFER,bufferData,gl->DYNAMIC_DRAW);
HXLINE( 227)		gl->vertexAttribPointer(shader->get_data()->aPosition->index,(int)2,gl->FLOAT,false,(int)20,(int)0);
HXLINE( 228)		gl->vertexAttribPointer(shader->get_data()->aTexCoord->index,(int)2,gl->FLOAT,false,(int)20,(int)8);
HXLINE( 229)		gl->vertexAttribPointer(shader->get_data()->aAlpha->index,(int)1,gl->FLOAT,false,(int)20,(int)16);
HXLINE( 231)		 ::openfl::display::BitmapData cacheBitmapData = null();
HXLINE( 232)		int lastIndex = (int)0;
HXLINE( 234)		{
HXLINE( 234)			int _g12 = (int)0;
HXDLIN( 234)			int _g4 = (drawCount + (int)1);
HXDLIN( 234)			while((_g12 < _g4)){
HXLINE( 234)				_g12 = (_g12 + (int)1);
HXDLIN( 234)				int i2 = (_g12 - (int)1);
HXLINE( 236)				if (( (bool)(::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->get(i2)) )) {
HXLINE( 238)					continue;
            				}
HXLINE( 242)				tile = tiles->__get(i2).StaticCast<  ::openfl::display::Tile >();
HXLINE( 243)				if (hx::IsNotNull( tile->tileset )) {
HXLINE( 243)					tileset = tile->tileset;
            				}
            				else {
HXLINE( 243)					tileset = defaultTileset;
            				}
HXLINE( 245)				if (hx::IsNotEq( tileset->bitmapData,cacheBitmapData )) {
HXLINE( 247)					if (hx::IsNotNull( cacheBitmapData )) {
HXLINE( 249)						shader->get_data()->uImage0->input = cacheBitmapData;
HXLINE( 250)						renderSession->shaderManager->setShader(shader);
HXLINE( 252)						int gl1 = gl->TRIANGLES;
HXDLIN( 252)						gl->drawArrays(gl1,(lastIndex * (int)6),((i2 - lastIndex) * (int)6));
            					}
HXLINE( 256)					cacheBitmapData = tileset->bitmapData;
HXLINE( 257)					lastIndex = i2;
            				}
HXLINE( 261)				bool _hx_tmp8;
HXDLIN( 261)				if ((i2 == drawCount)) {
HXLINE( 261)					_hx_tmp8 = hx::IsNotNull( tileset->bitmapData );
            				}
            				else {
HXLINE( 261)					_hx_tmp8 = false;
            				}
HXDLIN( 261)				if (_hx_tmp8) {
HXLINE( 263)					shader->get_data()->uImage0->input = tileset->bitmapData;
HXLINE( 264)					renderSession->shaderManager->setShader(shader);
HXLINE( 266)					int gl2 = gl->TRIANGLES;
HXDLIN( 266)					gl->drawArrays(gl2,(lastIndex * (int)6),(((i2 + (int)1) - lastIndex) * (int)6));
            				}
            			}
            		}
HXLINE( 272)		gl->disableVertexAttribArray(shader->get_data()->aAlpha->index);
HXLINE( 274)		tilemap->_hx___dirty = false;
HXLINE( 275)		tilemap->_hx___cacheAlpha = worldAlpha;
HXLINE( 277)		renderSession->filterManager->popObject(tilemap);
HXLINE( 278)		renderSession->maskManager->popRect();
HXLINE( 279)		renderSession->maskManager->popObject(tilemap,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,render,(void))

void GLTilemap_obj::_hx___skipTile( ::openfl::display::Tile tile,int i,int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_284___skipTile)
HXLINE( 286)		int tileOffset1 = (i * (int)30);
HXLINE( 288)		{
HXLINE( 288)			int bufferData1 = bufferData->byteOffset;
HXDLIN( 288)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData1 + ((tileOffset1 + (int)4) * (int)4)),(int)0);
            		}
HXLINE( 289)		{
HXLINE( 289)			int bufferData2 = bufferData->byteOffset;
HXDLIN( 289)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData2 + ((tileOffset1 + (int)9) * (int)4)),(int)0);
            		}
HXLINE( 290)		{
HXLINE( 290)			int bufferData3 = bufferData->byteOffset;
HXDLIN( 290)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData3 + ((tileOffset1 + (int)14) * (int)4)),(int)0);
            		}
HXLINE( 291)		{
HXLINE( 291)			int bufferData4 = bufferData->byteOffset;
HXDLIN( 291)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData4 + ((tileOffset1 + (int)19) * (int)4)),(int)0);
            		}
HXLINE( 292)		{
HXLINE( 292)			int bufferData5 = bufferData->byteOffset;
HXDLIN( 292)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData5 + ((tileOffset1 + (int)24) * (int)4)),(int)0);
            		}
HXLINE( 293)		{
HXLINE( 293)			int bufferData6 = bufferData->byteOffset;
HXDLIN( 293)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData6 + ((tileOffset1 + (int)29) * (int)4)),(int)0);
            		}
HXLINE( 295)		::openfl::_internal::renderer::opengl::GLTilemap_obj::_hx___skippedTiles->set(i,true);
HXLINE( 296)		tile->_hx___alphaDirty = true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___skipTile,(void))

void GLTilemap_obj::_hx___updateTileAlpha( ::openfl::display::Tile tile,Float worldAlpha,int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_301___updateTileAlpha)
HXLINE( 303)		Float alpha = (worldAlpha * tile->alpha);
HXLINE( 305)		{
HXLINE( 305)			int bufferData1 = bufferData->byteOffset;
HXDLIN( 305)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData1 + ((tileOffset + (int)4) * (int)4)),alpha);
            		}
HXLINE( 306)		{
HXLINE( 306)			int bufferData2 = bufferData->byteOffset;
HXDLIN( 306)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData2 + ((tileOffset + (int)9) * (int)4)),alpha);
            		}
HXLINE( 307)		{
HXLINE( 307)			int bufferData3 = bufferData->byteOffset;
HXDLIN( 307)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData3 + ((tileOffset + (int)14) * (int)4)),alpha);
            		}
HXLINE( 308)		{
HXLINE( 308)			int bufferData4 = bufferData->byteOffset;
HXDLIN( 308)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData4 + ((tileOffset + (int)19) * (int)4)),alpha);
            		}
HXLINE( 309)		{
HXLINE( 309)			int bufferData5 = bufferData->byteOffset;
HXDLIN( 309)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData5 + ((tileOffset + (int)24) * (int)4)),alpha);
            		}
HXLINE( 310)		{
HXLINE( 310)			int bufferData6 = bufferData->byteOffset;
HXDLIN( 310)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData6 + ((tileOffset + (int)29) * (int)4)),alpha);
            		}
HXLINE( 312)		tile->_hx___alphaDirty = false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___updateTileAlpha,(void))

void GLTilemap_obj::_hx___updateTileUV( ::openfl::display::Tile tile, ::openfl::display::Tileset tileset,int tileOffset, ::lime::utils::ArrayBufferView bufferData){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_317___updateTileUV)
HXLINE( 319)		 ::openfl::display::_Tileset::TileData tileData = tileset->_hx___data->__get(tile->id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 321)		if (hx::IsNull( tileData )) {
HXLINE( 321)			return;
            		}
HXLINE( 323)		Float x = tileData->_hx___uvX;
HXLINE( 324)		Float y = tileData->_hx___uvY;
HXLINE( 325)		Float x2 = tileData->_hx___uvWidth;
HXLINE( 326)		Float y2 = tileData->_hx___uvHeight;
HXLINE( 328)		{
HXLINE( 328)			int bufferData1 = bufferData->byteOffset;
HXDLIN( 328)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData1 + ((tileOffset + (int)2) * (int)4)),x);
            		}
HXLINE( 329)		{
HXLINE( 329)			int bufferData2 = bufferData->byteOffset;
HXDLIN( 329)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData2 + ((tileOffset + (int)3) * (int)4)),y);
            		}
HXLINE( 330)		{
HXLINE( 330)			int bufferData3 = bufferData->byteOffset;
HXDLIN( 330)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData3 + ((tileOffset + (int)7) * (int)4)),x2);
            		}
HXLINE( 331)		{
HXLINE( 331)			int bufferData4 = bufferData->byteOffset;
HXDLIN( 331)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData4 + ((tileOffset + (int)8) * (int)4)),y);
            		}
HXLINE( 332)		{
HXLINE( 332)			int bufferData5 = bufferData->byteOffset;
HXDLIN( 332)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData5 + ((tileOffset + (int)12) * (int)4)),x);
            		}
HXLINE( 333)		{
HXLINE( 333)			int bufferData6 = bufferData->byteOffset;
HXDLIN( 333)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData6 + ((tileOffset + (int)13) * (int)4)),y2);
            		}
HXLINE( 335)		{
HXLINE( 335)			int bufferData7 = bufferData->byteOffset;
HXDLIN( 335)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData7 + ((tileOffset + (int)17) * (int)4)),x);
            		}
HXLINE( 336)		{
HXLINE( 336)			int bufferData8 = bufferData->byteOffset;
HXDLIN( 336)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData8 + ((tileOffset + (int)18) * (int)4)),y2);
            		}
HXLINE( 337)		{
HXLINE( 337)			int bufferData9 = bufferData->byteOffset;
HXDLIN( 337)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData9 + ((tileOffset + (int)22) * (int)4)),x2);
            		}
HXLINE( 338)		{
HXLINE( 338)			int bufferData10 = bufferData->byteOffset;
HXDLIN( 338)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData10 + ((tileOffset + (int)23) * (int)4)),y);
            		}
HXLINE( 339)		{
HXLINE( 339)			int bufferData11 = bufferData->byteOffset;
HXDLIN( 339)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData11 + ((tileOffset + (int)27) * (int)4)),x2);
            		}
HXLINE( 340)		{
HXLINE( 340)			int bufferData12 = bufferData->byteOffset;
HXDLIN( 340)			::__hxcpp_memory_set_float(bufferData->buffer->b,(bufferData12 + ((tileOffset + (int)28) * (int)4)),y2);
            		}
HXLINE( 342)		tile->_hx___sourceDirty = false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(GLTilemap_obj,_hx___updateTileUV,(void))


GLTilemap_obj::GLTilemap_obj()
{
}

bool GLTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__skipTile") ) { outValue = _hx___skipTile_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__skippedTiles") ) { outValue = _hx___skippedTiles; return true; }
		if (HX_FIELD_EQ(inName,"__updateTileUV") ) { outValue = _hx___updateTileUV_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__updateTileAlpha") ) { outValue = _hx___updateTileAlpha_dyn(); return true; }
	}
	return false;
}

bool GLTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"__skippedTiles") ) { _hx___skippedTiles=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *GLTilemap_obj_sMemberStorageInfo = 0;
static hx::StaticInfo GLTilemap_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &GLTilemap_obj::_hx___skippedTiles,HX_HCSTRING("__skippedTiles","\xd5","\xfa","\xfa","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void GLTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::_hx___skippedTiles,"__skippedTiles");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::_hx___skippedTiles,"__skippedTiles");
};

#endif

hx::Class GLTilemap_obj::__mClass;

static ::String GLTilemap_obj_sStaticFields[] = {
	HX_HCSTRING("__skippedTiles","\xd5","\xfa","\xfa","\xbb"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("__skipTile","\x6d","\x2c","\x8a","\x66"),
	HX_HCSTRING("__updateTileAlpha","\xe7","\x06","\xd7","\x7f"),
	HX_HCSTRING("__updateTileUV","\x18","\xe7","\xac","\x3e"),
	::String(null())
};

void GLTilemap_obj::__register()
{
	hx::Object *dummy = new GLTilemap_obj;
	GLTilemap_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.GLTilemap","\x25","\xe7","\x07","\x88");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GLTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &GLTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = GLTilemap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GLTilemap_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< GLTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLTilemap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GLTilemap_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_40a075b64d21c9aa_29_boot)
HXLINE(  29)		_hx___skippedTiles =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
